// Code generated by Prisma (prisma@1.34.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  category: (where?: CategoryWhereInput) => Promise<boolean>;
  dimensions: (where?: DimensionsWhereInput) => Promise<boolean>;
  imageFile: (where?: ImageFileWhereInput) => Promise<boolean>;
  imageUse: (where?: ImageUseWhereInput) => Promise<boolean>;
  language: (where?: LanguageWhereInput) => Promise<boolean>;
  languageTranslation: (
    where?: LanguageTranslationWhereInput
  ) => Promise<boolean>;
  supportFile: (where?: SupportFileWhereInput) => Promise<boolean>;
  supportFileUse: (where?: SupportFileUseWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  team: (where?: TeamWhereInput) => Promise<boolean>;
  thumbnail: (where?: ThumbnailWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  videoFile: (where?: VideoFileWhereInput) => Promise<boolean>;
  videoProject: (where?: VideoProjectWhereInput) => Promise<boolean>;
  videoStream: (where?: VideoStreamWhereInput) => Promise<boolean>;
  videoUnit: (where?: VideoUnitWhereInput) => Promise<boolean>;
  videoUse: (where?: VideoUseWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  category: (where: CategoryWhereUniqueInput) => CategoryNullablePromise;
  categories: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Category>;
  categoriesConnection: (args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CategoryConnectionPromise;
  dimensions: (where: DimensionsWhereUniqueInput) => DimensionsNullablePromise;
  dimensionses: (args?: {
    where?: DimensionsWhereInput;
    orderBy?: DimensionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Dimensions>;
  dimensionsesConnection: (args?: {
    where?: DimensionsWhereInput;
    orderBy?: DimensionsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DimensionsConnectionPromise;
  imageFile: (where: ImageFileWhereUniqueInput) => ImageFileNullablePromise;
  imageFiles: (args?: {
    where?: ImageFileWhereInput;
    orderBy?: ImageFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ImageFile>;
  imageFilesConnection: (args?: {
    where?: ImageFileWhereInput;
    orderBy?: ImageFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImageFileConnectionPromise;
  imageUse: (where: ImageUseWhereUniqueInput) => ImageUseNullablePromise;
  imageUses: (args?: {
    where?: ImageUseWhereInput;
    orderBy?: ImageUseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ImageUse>;
  imageUsesConnection: (args?: {
    where?: ImageUseWhereInput;
    orderBy?: ImageUseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImageUseConnectionPromise;
  language: (where: LanguageWhereUniqueInput) => LanguageNullablePromise;
  languages: (args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Language>;
  languagesConnection: (args?: {
    where?: LanguageWhereInput;
    orderBy?: LanguageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LanguageConnectionPromise;
  languageTranslation: (
    where: LanguageTranslationWhereUniqueInput
  ) => LanguageTranslationNullablePromise;
  languageTranslations: (args?: {
    where?: LanguageTranslationWhereInput;
    orderBy?: LanguageTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<LanguageTranslation>;
  languageTranslationsConnection: (args?: {
    where?: LanguageTranslationWhereInput;
    orderBy?: LanguageTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LanguageTranslationConnectionPromise;
  supportFile: (
    where: SupportFileWhereUniqueInput
  ) => SupportFileNullablePromise;
  supportFiles: (args?: {
    where?: SupportFileWhereInput;
    orderBy?: SupportFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SupportFile>;
  supportFilesConnection: (args?: {
    where?: SupportFileWhereInput;
    orderBy?: SupportFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SupportFileConnectionPromise;
  supportFileUse: (
    where: SupportFileUseWhereUniqueInput
  ) => SupportFileUseNullablePromise;
  supportFileUses: (args?: {
    where?: SupportFileUseWhereInput;
    orderBy?: SupportFileUseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SupportFileUse>;
  supportFileUsesConnection: (args?: {
    where?: SupportFileUseWhereInput;
    orderBy?: SupportFileUseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SupportFileUseConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagNullablePromise;
  tags: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tag>;
  tagsConnection: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TagConnectionPromise;
  team: (where: TeamWhereUniqueInput) => TeamNullablePromise;
  teams: (args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Team>;
  teamsConnection: (args?: {
    where?: TeamWhereInput;
    orderBy?: TeamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TeamConnectionPromise;
  thumbnail: (where: ThumbnailWhereUniqueInput) => ThumbnailNullablePromise;
  thumbnails: (args?: {
    where?: ThumbnailWhereInput;
    orderBy?: ThumbnailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Thumbnail>;
  thumbnailsConnection: (args?: {
    where?: ThumbnailWhereInput;
    orderBy?: ThumbnailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ThumbnailConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  videoFile: (where: VideoFileWhereUniqueInput) => VideoFileNullablePromise;
  videoFiles: (args?: {
    where?: VideoFileWhereInput;
    orderBy?: VideoFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<VideoFile>;
  videoFilesConnection: (args?: {
    where?: VideoFileWhereInput;
    orderBy?: VideoFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VideoFileConnectionPromise;
  videoProject: (
    where: VideoProjectWhereUniqueInput
  ) => VideoProjectNullablePromise;
  videoProjects: (args?: {
    where?: VideoProjectWhereInput;
    orderBy?: VideoProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<VideoProject>;
  videoProjectsConnection: (args?: {
    where?: VideoProjectWhereInput;
    orderBy?: VideoProjectOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VideoProjectConnectionPromise;
  videoStream: (
    where: VideoStreamWhereUniqueInput
  ) => VideoStreamNullablePromise;
  videoStreams: (args?: {
    where?: VideoStreamWhereInput;
    orderBy?: VideoStreamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<VideoStream>;
  videoStreamsConnection: (args?: {
    where?: VideoStreamWhereInput;
    orderBy?: VideoStreamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VideoStreamConnectionPromise;
  videoUnit: (where: VideoUnitWhereUniqueInput) => VideoUnitNullablePromise;
  videoUnits: (args?: {
    where?: VideoUnitWhereInput;
    orderBy?: VideoUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<VideoUnit>;
  videoUnitsConnection: (args?: {
    where?: VideoUnitWhereInput;
    orderBy?: VideoUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VideoUnitConnectionPromise;
  videoUse: (where: VideoUseWhereUniqueInput) => VideoUseNullablePromise;
  videoUses: (args?: {
    where?: VideoUseWhereInput;
    orderBy?: VideoUseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<VideoUse>;
  videoUsesConnection: (args?: {
    where?: VideoUseWhereInput;
    orderBy?: VideoUseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => VideoUseConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCategory: (data: CategoryCreateInput) => CategoryPromise;
  updateCategory: (args: {
    data: CategoryUpdateInput;
    where: CategoryWhereUniqueInput;
  }) => CategoryPromise;
  upsertCategory: (args: {
    where: CategoryWhereUniqueInput;
    create: CategoryCreateInput;
    update: CategoryUpdateInput;
  }) => CategoryPromise;
  deleteCategory: (where: CategoryWhereUniqueInput) => CategoryPromise;
  deleteManyCategories: (where?: CategoryWhereInput) => BatchPayloadPromise;
  createDimensions: (data: DimensionsCreateInput) => DimensionsPromise;
  updateDimensions: (args: {
    data: DimensionsUpdateInput;
    where: DimensionsWhereUniqueInput;
  }) => DimensionsPromise;
  updateManyDimensionses: (args: {
    data: DimensionsUpdateManyMutationInput;
    where?: DimensionsWhereInput;
  }) => BatchPayloadPromise;
  upsertDimensions: (args: {
    where: DimensionsWhereUniqueInput;
    create: DimensionsCreateInput;
    update: DimensionsUpdateInput;
  }) => DimensionsPromise;
  deleteDimensions: (where: DimensionsWhereUniqueInput) => DimensionsPromise;
  deleteManyDimensionses: (where?: DimensionsWhereInput) => BatchPayloadPromise;
  createImageFile: (data: ImageFileCreateInput) => ImageFilePromise;
  updateImageFile: (args: {
    data: ImageFileUpdateInput;
    where: ImageFileWhereUniqueInput;
  }) => ImageFilePromise;
  updateManyImageFiles: (args: {
    data: ImageFileUpdateManyMutationInput;
    where?: ImageFileWhereInput;
  }) => BatchPayloadPromise;
  upsertImageFile: (args: {
    where: ImageFileWhereUniqueInput;
    create: ImageFileCreateInput;
    update: ImageFileUpdateInput;
  }) => ImageFilePromise;
  deleteImageFile: (where: ImageFileWhereUniqueInput) => ImageFilePromise;
  deleteManyImageFiles: (where?: ImageFileWhereInput) => BatchPayloadPromise;
  createImageUse: (data: ImageUseCreateInput) => ImageUsePromise;
  updateImageUse: (args: {
    data: ImageUseUpdateInput;
    where: ImageUseWhereUniqueInput;
  }) => ImageUsePromise;
  updateManyImageUses: (args: {
    data: ImageUseUpdateManyMutationInput;
    where?: ImageUseWhereInput;
  }) => BatchPayloadPromise;
  upsertImageUse: (args: {
    where: ImageUseWhereUniqueInput;
    create: ImageUseCreateInput;
    update: ImageUseUpdateInput;
  }) => ImageUsePromise;
  deleteImageUse: (where: ImageUseWhereUniqueInput) => ImageUsePromise;
  deleteManyImageUses: (where?: ImageUseWhereInput) => BatchPayloadPromise;
  createLanguage: (data: LanguageCreateInput) => LanguagePromise;
  updateLanguage: (args: {
    data: LanguageUpdateInput;
    where: LanguageWhereUniqueInput;
  }) => LanguagePromise;
  updateManyLanguages: (args: {
    data: LanguageUpdateManyMutationInput;
    where?: LanguageWhereInput;
  }) => BatchPayloadPromise;
  upsertLanguage: (args: {
    where: LanguageWhereUniqueInput;
    create: LanguageCreateInput;
    update: LanguageUpdateInput;
  }) => LanguagePromise;
  deleteLanguage: (where: LanguageWhereUniqueInput) => LanguagePromise;
  deleteManyLanguages: (where?: LanguageWhereInput) => BatchPayloadPromise;
  createLanguageTranslation: (
    data: LanguageTranslationCreateInput
  ) => LanguageTranslationPromise;
  updateLanguageTranslation: (args: {
    data: LanguageTranslationUpdateInput;
    where: LanguageTranslationWhereUniqueInput;
  }) => LanguageTranslationPromise;
  updateManyLanguageTranslations: (args: {
    data: LanguageTranslationUpdateManyMutationInput;
    where?: LanguageTranslationWhereInput;
  }) => BatchPayloadPromise;
  upsertLanguageTranslation: (args: {
    where: LanguageTranslationWhereUniqueInput;
    create: LanguageTranslationCreateInput;
    update: LanguageTranslationUpdateInput;
  }) => LanguageTranslationPromise;
  deleteLanguageTranslation: (
    where: LanguageTranslationWhereUniqueInput
  ) => LanguageTranslationPromise;
  deleteManyLanguageTranslations: (
    where?: LanguageTranslationWhereInput
  ) => BatchPayloadPromise;
  createSupportFile: (data: SupportFileCreateInput) => SupportFilePromise;
  updateSupportFile: (args: {
    data: SupportFileUpdateInput;
    where: SupportFileWhereUniqueInput;
  }) => SupportFilePromise;
  updateManySupportFiles: (args: {
    data: SupportFileUpdateManyMutationInput;
    where?: SupportFileWhereInput;
  }) => BatchPayloadPromise;
  upsertSupportFile: (args: {
    where: SupportFileWhereUniqueInput;
    create: SupportFileCreateInput;
    update: SupportFileUpdateInput;
  }) => SupportFilePromise;
  deleteSupportFile: (where: SupportFileWhereUniqueInput) => SupportFilePromise;
  deleteManySupportFiles: (
    where?: SupportFileWhereInput
  ) => BatchPayloadPromise;
  createSupportFileUse: (
    data: SupportFileUseCreateInput
  ) => SupportFileUsePromise;
  updateSupportFileUse: (args: {
    data: SupportFileUseUpdateInput;
    where: SupportFileUseWhereUniqueInput;
  }) => SupportFileUsePromise;
  updateManySupportFileUses: (args: {
    data: SupportFileUseUpdateManyMutationInput;
    where?: SupportFileUseWhereInput;
  }) => BatchPayloadPromise;
  upsertSupportFileUse: (args: {
    where: SupportFileUseWhereUniqueInput;
    create: SupportFileUseCreateInput;
    update: SupportFileUseUpdateInput;
  }) => SupportFileUsePromise;
  deleteSupportFileUse: (
    where: SupportFileUseWhereUniqueInput
  ) => SupportFileUsePromise;
  deleteManySupportFileUses: (
    where?: SupportFileUseWhereInput
  ) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (args: {
    data: TagUpdateInput;
    where: TagWhereUniqueInput;
  }) => TagPromise;
  upsertTag: (args: {
    where: TagWhereUniqueInput;
    create: TagCreateInput;
    update: TagUpdateInput;
  }) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createTeam: (data: TeamCreateInput) => TeamPromise;
  updateTeam: (args: {
    data: TeamUpdateInput;
    where: TeamWhereUniqueInput;
  }) => TeamPromise;
  updateManyTeams: (args: {
    data: TeamUpdateManyMutationInput;
    where?: TeamWhereInput;
  }) => BatchPayloadPromise;
  upsertTeam: (args: {
    where: TeamWhereUniqueInput;
    create: TeamCreateInput;
    update: TeamUpdateInput;
  }) => TeamPromise;
  deleteTeam: (where: TeamWhereUniqueInput) => TeamPromise;
  deleteManyTeams: (where?: TeamWhereInput) => BatchPayloadPromise;
  createThumbnail: (data: ThumbnailCreateInput) => ThumbnailPromise;
  updateThumbnail: (args: {
    data: ThumbnailUpdateInput;
    where: ThumbnailWhereUniqueInput;
  }) => ThumbnailPromise;
  updateManyThumbnails: (args: {
    data: ThumbnailUpdateManyMutationInput;
    where?: ThumbnailWhereInput;
  }) => BatchPayloadPromise;
  upsertThumbnail: (args: {
    where: ThumbnailWhereUniqueInput;
    create: ThumbnailCreateInput;
    update: ThumbnailUpdateInput;
  }) => ThumbnailPromise;
  deleteThumbnail: (where: ThumbnailWhereUniqueInput) => ThumbnailPromise;
  deleteManyThumbnails: (where?: ThumbnailWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createVideoFile: (data: VideoFileCreateInput) => VideoFilePromise;
  updateVideoFile: (args: {
    data: VideoFileUpdateInput;
    where: VideoFileWhereUniqueInput;
  }) => VideoFilePromise;
  updateManyVideoFiles: (args: {
    data: VideoFileUpdateManyMutationInput;
    where?: VideoFileWhereInput;
  }) => BatchPayloadPromise;
  upsertVideoFile: (args: {
    where: VideoFileWhereUniqueInput;
    create: VideoFileCreateInput;
    update: VideoFileUpdateInput;
  }) => VideoFilePromise;
  deleteVideoFile: (where: VideoFileWhereUniqueInput) => VideoFilePromise;
  deleteManyVideoFiles: (where?: VideoFileWhereInput) => BatchPayloadPromise;
  createVideoProject: (data: VideoProjectCreateInput) => VideoProjectPromise;
  updateVideoProject: (args: {
    data: VideoProjectUpdateInput;
    where: VideoProjectWhereUniqueInput;
  }) => VideoProjectPromise;
  updateManyVideoProjects: (args: {
    data: VideoProjectUpdateManyMutationInput;
    where?: VideoProjectWhereInput;
  }) => BatchPayloadPromise;
  upsertVideoProject: (args: {
    where: VideoProjectWhereUniqueInput;
    create: VideoProjectCreateInput;
    update: VideoProjectUpdateInput;
  }) => VideoProjectPromise;
  deleteVideoProject: (
    where: VideoProjectWhereUniqueInput
  ) => VideoProjectPromise;
  deleteManyVideoProjects: (
    where?: VideoProjectWhereInput
  ) => BatchPayloadPromise;
  createVideoStream: (data: VideoStreamCreateInput) => VideoStreamPromise;
  updateVideoStream: (args: {
    data: VideoStreamUpdateInput;
    where: VideoStreamWhereUniqueInput;
  }) => VideoStreamPromise;
  updateManyVideoStreams: (args: {
    data: VideoStreamUpdateManyMutationInput;
    where?: VideoStreamWhereInput;
  }) => BatchPayloadPromise;
  upsertVideoStream: (args: {
    where: VideoStreamWhereUniqueInput;
    create: VideoStreamCreateInput;
    update: VideoStreamUpdateInput;
  }) => VideoStreamPromise;
  deleteVideoStream: (where: VideoStreamWhereUniqueInput) => VideoStreamPromise;
  deleteManyVideoStreams: (
    where?: VideoStreamWhereInput
  ) => BatchPayloadPromise;
  createVideoUnit: (data: VideoUnitCreateInput) => VideoUnitPromise;
  updateVideoUnit: (args: {
    data: VideoUnitUpdateInput;
    where: VideoUnitWhereUniqueInput;
  }) => VideoUnitPromise;
  updateManyVideoUnits: (args: {
    data: VideoUnitUpdateManyMutationInput;
    where?: VideoUnitWhereInput;
  }) => BatchPayloadPromise;
  upsertVideoUnit: (args: {
    where: VideoUnitWhereUniqueInput;
    create: VideoUnitCreateInput;
    update: VideoUnitUpdateInput;
  }) => VideoUnitPromise;
  deleteVideoUnit: (where: VideoUnitWhereUniqueInput) => VideoUnitPromise;
  deleteManyVideoUnits: (where?: VideoUnitWhereInput) => BatchPayloadPromise;
  createVideoUse: (data: VideoUseCreateInput) => VideoUsePromise;
  updateVideoUse: (args: {
    data: VideoUseUpdateInput;
    where: VideoUseWhereUniqueInput;
  }) => VideoUsePromise;
  updateManyVideoUses: (args: {
    data: VideoUseUpdateManyMutationInput;
    where?: VideoUseWhereInput;
  }) => BatchPayloadPromise;
  upsertVideoUse: (args: {
    where: VideoUseWhereUniqueInput;
    create: VideoUseCreateInput;
    update: VideoUseUpdateInput;
  }) => VideoUsePromise;
  deleteVideoUse: (where: VideoUseWhereUniqueInput) => VideoUsePromise;
  deleteManyVideoUses: (where?: VideoUseWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  category: (
    where?: CategorySubscriptionWhereInput
  ) => CategorySubscriptionPayloadSubscription;
  dimensions: (
    where?: DimensionsSubscriptionWhereInput
  ) => DimensionsSubscriptionPayloadSubscription;
  imageFile: (
    where?: ImageFileSubscriptionWhereInput
  ) => ImageFileSubscriptionPayloadSubscription;
  imageUse: (
    where?: ImageUseSubscriptionWhereInput
  ) => ImageUseSubscriptionPayloadSubscription;
  language: (
    where?: LanguageSubscriptionWhereInput
  ) => LanguageSubscriptionPayloadSubscription;
  languageTranslation: (
    where?: LanguageTranslationSubscriptionWhereInput
  ) => LanguageTranslationSubscriptionPayloadSubscription;
  supportFile: (
    where?: SupportFileSubscriptionWhereInput
  ) => SupportFileSubscriptionPayloadSubscription;
  supportFileUse: (
    where?: SupportFileUseSubscriptionWhereInput
  ) => SupportFileUseSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  team: (
    where?: TeamSubscriptionWhereInput
  ) => TeamSubscriptionPayloadSubscription;
  thumbnail: (
    where?: ThumbnailSubscriptionWhereInput
  ) => ThumbnailSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  videoFile: (
    where?: VideoFileSubscriptionWhereInput
  ) => VideoFileSubscriptionPayloadSubscription;
  videoProject: (
    where?: VideoProjectSubscriptionWhereInput
  ) => VideoProjectSubscriptionPayloadSubscription;
  videoStream: (
    where?: VideoStreamSubscriptionWhereInput
  ) => VideoStreamSubscriptionPayloadSubscription;
  videoUnit: (
    where?: VideoUnitSubscriptionWhereInput
  ) => VideoUnitSubscriptionPayloadSubscription;
  videoUse: (
    where?: VideoUseSubscriptionWhereInput
  ) => VideoUseSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type VideoQuality = "WEB" | "BROADCAST";

export type ImageFileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "alt_ASC"
  | "alt_DESC"
  | "longdesc_ASC"
  | "longdesc_DESC"
  | "caption_ASC"
  | "caption_DESC"
  | "filename_ASC"
  | "filename_DESC"
  | "filetype_ASC"
  | "filetype_DESC"
  | "filesize_ASC"
  | "filesize_DESC"
  | "md5_ASC"
  | "md5_DESC"
  | "url_ASC"
  | "url_DESC";

export type ThumbnailOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "size_ASC"
  | "size_DESC";

export type VideoUseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type ThumbnailSize = "SMALL" | "MEDIUM" | "LARGE" | "FULL";

export type VideoUnitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "descPublic_ASC"
  | "descPublic_DESC";

export type TeamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "organization_ASC"
  | "organization_DESC"
  | "isConfirmed_ASC"
  | "isConfirmed_DESC";

export type LanguageTranslationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type ContentType =
  | "AUDIO"
  | "VIDEO"
  | "DOCUMENT"
  | "IMAGE"
  | "TEACHING_MATERIAL";

export type ProjectPublishStatus =
  | "DRAFT"
  | "PUBLISHING"
  | "PUBLISHED"
  | "PUBLISHED_MODIFIED"
  | "EMBARGOED";

export type Permission =
  | "SUBSCRIBER"
  | "AUTHOR"
  | "EDITOR"
  | "TEAM_ADMIN"
  | "ADMIN";

export type VideoFileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "filetype_ASC"
  | "filetype_DESC"
  | "filename_ASC"
  | "filename_DESC"
  | "quality_ASC"
  | "quality_DESC"
  | "videoBurnedInStatus_ASC"
  | "videoBurnedInStatus_DESC"
  | "url_ASC"
  | "url_DESC"
  | "md5_ASC"
  | "md5_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "bitrate_ASC"
  | "bitrate_DESC"
  | "filesize_ASC"
  | "filesize_DESC";

export type DimensionsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "width_ASC"
  | "width_DESC"
  | "height_ASC"
  | "height_DESC";

export type VideoStreamOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "site_ASC"
  | "site_DESC"
  | "url_ASC"
  | "url_DESC"
  | "embedUrl_ASC"
  | "embedUrl_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "tempToken_ASC"
  | "tempToken_DESC"
  | "tempTokenExpiry_ASC"
  | "tempTokenExpiry_DESC"
  | "jobTitle_ASC"
  | "jobTitle_DESC"
  | "country_ASC"
  | "country_DESC"
  | "city_ASC"
  | "city_DESC"
  | "howHeard_ASC"
  | "howHeard_DESC"
  | "isConfirmed_ASC"
  | "isConfirmed_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type TagOrderByInput = "id_ASC" | "id_DESC";

export type TextDirection = "LTR" | "RTL";

export type ImageUseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type LanguageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "languageCode_ASC"
  | "languageCode_DESC"
  | "locale_ASC"
  | "locale_DESC"
  | "textDirection_ASC"
  | "textDirection_DESC"
  | "displayName_ASC"
  | "displayName_DESC"
  | "nativeName_ASC"
  | "nativeName_DESC";

export type SupportFileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "url_ASC"
  | "url_DESC"
  | "md5_ASC"
  | "md5_DESC"
  | "filename_ASC"
  | "filename_DESC"
  | "filetype_ASC"
  | "filetype_DESC"
  | "filesize_ASC"
  | "filesize_DESC";

export type SupportFileUseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type ProjectVisibility = "INTERNAL" | "PUBLIC";

export type VideoProjectOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "projectType_ASC"
  | "projectType_DESC"
  | "projectTitle_ASC"
  | "projectTitle_DESC"
  | "descPublic_ASC"
  | "descPublic_DESC"
  | "descInternal_ASC"
  | "descInternal_DESC"
  | "status_ASC"
  | "status_DESC"
  | "visibility_ASC"
  | "visibility_DESC"
  | "protectImages_ASC"
  | "protectImages_DESC";

export type VideoBurnedInStatus = "SUBTITLED" | "CAPTIONED" | "CLEAN";

export type CategoryOrderByInput = "id_ASC" | "id_DESC";

export type ProjectType = "LANGUAGE";

export interface SupportFileUseCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export type CategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LanguageTranslationCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  language: LanguageCreateOneInput;
}

export interface ImageFileCreateManyInput {
  create?: Maybe<ImageFileCreateInput[] | ImageFileCreateInput>;
  connect?: Maybe<ImageFileWhereUniqueInput[] | ImageFileWhereUniqueInput>;
}

export interface LanguageCreateOneInput {
  create?: Maybe<LanguageCreateInput>;
  connect?: Maybe<LanguageWhereUniqueInput>;
}

export interface TeamUpdateInput {
  name?: Maybe<String>;
  organization?: Maybe<String>;
  members?: Maybe<UserUpdateManyWithoutTeamInput>;
  contentTypes?: Maybe<TeamUpdatecontentTypesInput>;
  isConfirmed?: Maybe<Boolean>;
}

export interface LanguageCreateInput {
  id?: Maybe<ID_Input>;
  languageCode: String;
  locale: String;
  textDirection?: Maybe<TextDirection>;
  displayName: String;
  nativeName: String;
}

export interface VideoUseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VideoUseWhereInput>;
  AND?: Maybe<
    VideoUseSubscriptionWhereInput[] | VideoUseSubscriptionWhereInput
  >;
  OR?: Maybe<VideoUseSubscriptionWhereInput[] | VideoUseSubscriptionWhereInput>;
  NOT?: Maybe<
    VideoUseSubscriptionWhereInput[] | VideoUseSubscriptionWhereInput
  >;
}

export interface CategoryUpdateInput {
  translations?: Maybe<LanguageTranslationUpdateManyInput>;
}

export interface VideoStreamSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VideoStreamWhereInput>;
  AND?: Maybe<
    VideoStreamSubscriptionWhereInput[] | VideoStreamSubscriptionWhereInput
  >;
  OR?: Maybe<
    VideoStreamSubscriptionWhereInput[] | VideoStreamSubscriptionWhereInput
  >;
  NOT?: Maybe<
    VideoStreamSubscriptionWhereInput[] | VideoStreamSubscriptionWhereInput
  >;
}

export interface LanguageTranslationUpdateManyInput {
  create?: Maybe<
    LanguageTranslationCreateInput[] | LanguageTranslationCreateInput
  >;
  update?: Maybe<
    | LanguageTranslationUpdateWithWhereUniqueNestedInput[]
    | LanguageTranslationUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | LanguageTranslationUpsertWithWhereUniqueNestedInput[]
    | LanguageTranslationUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    LanguageTranslationWhereUniqueInput[] | LanguageTranslationWhereUniqueInput
  >;
  connect?: Maybe<
    LanguageTranslationWhereUniqueInput[] | LanguageTranslationWhereUniqueInput
  >;
  set?: Maybe<
    LanguageTranslationWhereUniqueInput[] | LanguageTranslationWhereUniqueInput
  >;
  disconnect?: Maybe<
    LanguageTranslationWhereUniqueInput[] | LanguageTranslationWhereUniqueInput
  >;
  deleteMany?: Maybe<
    LanguageTranslationScalarWhereInput[] | LanguageTranslationScalarWhereInput
  >;
  updateMany?: Maybe<
    | LanguageTranslationUpdateManyWithWhereNestedInput[]
    | LanguageTranslationUpdateManyWithWhereNestedInput
  >;
}

export type ImageUseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface LanguageTranslationUpdateWithWhereUniqueNestedInput {
  where: LanguageTranslationWhereUniqueInput;
  data: LanguageTranslationUpdateDataInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface LanguageTranslationUpdateDataInput {
  name?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface TeamSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TeamWhereInput>;
  AND?: Maybe<TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput>;
  OR?: Maybe<TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput>;
  NOT?: Maybe<TeamSubscriptionWhereInput[] | TeamSubscriptionWhereInput>;
}

export interface LanguageUpdateOneRequiredInput {
  create?: Maybe<LanguageCreateInput>;
  update?: Maybe<LanguageUpdateDataInput>;
  upsert?: Maybe<LanguageUpsertNestedInput>;
  connect?: Maybe<LanguageWhereUniqueInput>;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TagWhereInput>;
  AND?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  OR?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  NOT?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
}

export interface LanguageUpdateDataInput {
  languageCode?: Maybe<String>;
  locale?: Maybe<String>;
  textDirection?: Maybe<TextDirection>;
  displayName?: Maybe<String>;
  nativeName?: Maybe<String>;
}

export interface SupportFileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SupportFileWhereInput>;
  AND?: Maybe<
    SupportFileSubscriptionWhereInput[] | SupportFileSubscriptionWhereInput
  >;
  OR?: Maybe<
    SupportFileSubscriptionWhereInput[] | SupportFileSubscriptionWhereInput
  >;
  NOT?: Maybe<
    SupportFileSubscriptionWhereInput[] | SupportFileSubscriptionWhereInput
  >;
}

export interface LanguageUpsertNestedInput {
  update: LanguageUpdateDataInput;
  create: LanguageCreateInput;
}

export type LanguageTranslationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LanguageTranslationUpsertWithWhereUniqueNestedInput {
  where: LanguageTranslationWhereUniqueInput;
  update: LanguageTranslationUpdateDataInput;
  create: LanguageTranslationCreateInput;
}

export interface ImageUseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ImageUseWhereInput>;
  AND?: Maybe<
    ImageUseSubscriptionWhereInput[] | ImageUseSubscriptionWhereInput
  >;
  OR?: Maybe<ImageUseSubscriptionWhereInput[] | ImageUseSubscriptionWhereInput>;
  NOT?: Maybe<
    ImageUseSubscriptionWhereInput[] | ImageUseSubscriptionWhereInput
  >;
}

export interface LanguageTranslationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    LanguageTranslationScalarWhereInput[] | LanguageTranslationScalarWhereInput
  >;
  OR?: Maybe<
    LanguageTranslationScalarWhereInput[] | LanguageTranslationScalarWhereInput
  >;
  NOT?: Maybe<
    LanguageTranslationScalarWhereInput[] | LanguageTranslationScalarWhereInput
  >;
}

export type SupportFileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LanguageTranslationUpdateManyWithWhereNestedInput {
  where: LanguageTranslationScalarWhereInput;
  data: LanguageTranslationUpdateManyDataInput;
}

export interface CategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CategoryWhereInput>;
  AND?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
  OR?: Maybe<CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput>;
  NOT?: Maybe<
    CategorySubscriptionWhereInput[] | CategorySubscriptionWhereInput
  >;
}

export interface LanguageTranslationUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface SupportFileUseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<SupportFileUseWhereInput[] | SupportFileUseWhereInput>;
  OR?: Maybe<SupportFileUseWhereInput[] | SupportFileUseWhereInput>;
  NOT?: Maybe<SupportFileUseWhereInput[] | SupportFileUseWhereInput>;
}

export interface UserUpdateDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  tempToken?: Maybe<String>;
  tempTokenExpiry?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  country?: Maybe<String>;
  city?: Maybe<String>;
  howHeard?: Maybe<String>;
  permissions?: Maybe<UserUpdatepermissionsInput>;
  team?: Maybe<TeamUpdateOneWithoutMembersInput>;
  isConfirmed?: Maybe<Boolean>;
}

export interface VideoUseUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface VideoUnitUpdateManyMutationInput {
  title?: Maybe<String>;
  descPublic?: Maybe<String>;
}

export interface DimensionsCreateInput {
  id?: Maybe<ID_Input>;
  width?: Maybe<Int>;
  height?: Maybe<Int>;
}

export interface VideoUnitUpdateInput {
  language?: Maybe<LanguageUpdateOneInput>;
  title?: Maybe<String>;
  descPublic?: Maybe<String>;
  files?: Maybe<VideoFileUpdateManyInput>;
  tags?: Maybe<TagUpdateManyInput>;
  categories?: Maybe<CategoryUpdateManyInput>;
  thumbnails?: Maybe<ThumbnailUpdateManyInput>;
}

export interface DimensionsUpdateInput {
  width?: Maybe<Int>;
  height?: Maybe<Int>;
}

export interface VideoStreamUpdateInput {
  site?: Maybe<String>;
  url?: Maybe<String>;
  embedUrl?: Maybe<String>;
}

export interface DimensionsUpdateManyMutationInput {
  width?: Maybe<Int>;
  height?: Maybe<Int>;
}

export type TagWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ImageFileCreateInput {
  id?: Maybe<ID_Input>;
  language?: Maybe<LanguageCreateOneInput>;
  dimensions?: Maybe<DimensionsCreateOneInput>;
  alt?: Maybe<String>;
  longdesc?: Maybe<String>;
  caption?: Maybe<String>;
  filename?: Maybe<String>;
  filetype?: Maybe<String>;
  filesize?: Maybe<Float>;
  use?: Maybe<ImageUseCreateOneInput>;
  md5?: Maybe<String>;
  url?: Maybe<String>;
}

export interface TagWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  translations_every?: Maybe<LanguageTranslationWhereInput>;
  translations_some?: Maybe<LanguageTranslationWhereInput>;
  translations_none?: Maybe<LanguageTranslationWhereInput>;
  AND?: Maybe<TagWhereInput[] | TagWhereInput>;
  OR?: Maybe<TagWhereInput[] | TagWhereInput>;
  NOT?: Maybe<TagWhereInput[] | TagWhereInput>;
}

export interface DimensionsCreateOneInput {
  create?: Maybe<DimensionsCreateInput>;
  connect?: Maybe<DimensionsWhereUniqueInput>;
}

export interface ImageFileScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  alt?: Maybe<String>;
  alt_not?: Maybe<String>;
  alt_in?: Maybe<String[] | String>;
  alt_not_in?: Maybe<String[] | String>;
  alt_lt?: Maybe<String>;
  alt_lte?: Maybe<String>;
  alt_gt?: Maybe<String>;
  alt_gte?: Maybe<String>;
  alt_contains?: Maybe<String>;
  alt_not_contains?: Maybe<String>;
  alt_starts_with?: Maybe<String>;
  alt_not_starts_with?: Maybe<String>;
  alt_ends_with?: Maybe<String>;
  alt_not_ends_with?: Maybe<String>;
  longdesc?: Maybe<String>;
  longdesc_not?: Maybe<String>;
  longdesc_in?: Maybe<String[] | String>;
  longdesc_not_in?: Maybe<String[] | String>;
  longdesc_lt?: Maybe<String>;
  longdesc_lte?: Maybe<String>;
  longdesc_gt?: Maybe<String>;
  longdesc_gte?: Maybe<String>;
  longdesc_contains?: Maybe<String>;
  longdesc_not_contains?: Maybe<String>;
  longdesc_starts_with?: Maybe<String>;
  longdesc_not_starts_with?: Maybe<String>;
  longdesc_ends_with?: Maybe<String>;
  longdesc_not_ends_with?: Maybe<String>;
  caption?: Maybe<String>;
  caption_not?: Maybe<String>;
  caption_in?: Maybe<String[] | String>;
  caption_not_in?: Maybe<String[] | String>;
  caption_lt?: Maybe<String>;
  caption_lte?: Maybe<String>;
  caption_gt?: Maybe<String>;
  caption_gte?: Maybe<String>;
  caption_contains?: Maybe<String>;
  caption_not_contains?: Maybe<String>;
  caption_starts_with?: Maybe<String>;
  caption_not_starts_with?: Maybe<String>;
  caption_ends_with?: Maybe<String>;
  caption_not_ends_with?: Maybe<String>;
  filename?: Maybe<String>;
  filename_not?: Maybe<String>;
  filename_in?: Maybe<String[] | String>;
  filename_not_in?: Maybe<String[] | String>;
  filename_lt?: Maybe<String>;
  filename_lte?: Maybe<String>;
  filename_gt?: Maybe<String>;
  filename_gte?: Maybe<String>;
  filename_contains?: Maybe<String>;
  filename_not_contains?: Maybe<String>;
  filename_starts_with?: Maybe<String>;
  filename_not_starts_with?: Maybe<String>;
  filename_ends_with?: Maybe<String>;
  filename_not_ends_with?: Maybe<String>;
  filetype?: Maybe<String>;
  filetype_not?: Maybe<String>;
  filetype_in?: Maybe<String[] | String>;
  filetype_not_in?: Maybe<String[] | String>;
  filetype_lt?: Maybe<String>;
  filetype_lte?: Maybe<String>;
  filetype_gt?: Maybe<String>;
  filetype_gte?: Maybe<String>;
  filetype_contains?: Maybe<String>;
  filetype_not_contains?: Maybe<String>;
  filetype_starts_with?: Maybe<String>;
  filetype_not_starts_with?: Maybe<String>;
  filetype_ends_with?: Maybe<String>;
  filetype_not_ends_with?: Maybe<String>;
  filesize?: Maybe<Float>;
  filesize_not?: Maybe<Float>;
  filesize_in?: Maybe<Float[] | Float>;
  filesize_not_in?: Maybe<Float[] | Float>;
  filesize_lt?: Maybe<Float>;
  filesize_lte?: Maybe<Float>;
  filesize_gt?: Maybe<Float>;
  filesize_gte?: Maybe<Float>;
  md5?: Maybe<String>;
  md5_not?: Maybe<String>;
  md5_in?: Maybe<String[] | String>;
  md5_not_in?: Maybe<String[] | String>;
  md5_lt?: Maybe<String>;
  md5_lte?: Maybe<String>;
  md5_gt?: Maybe<String>;
  md5_gte?: Maybe<String>;
  md5_contains?: Maybe<String>;
  md5_not_contains?: Maybe<String>;
  md5_starts_with?: Maybe<String>;
  md5_not_starts_with?: Maybe<String>;
  md5_ends_with?: Maybe<String>;
  md5_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<ImageFileScalarWhereInput[] | ImageFileScalarWhereInput>;
  OR?: Maybe<ImageFileScalarWhereInput[] | ImageFileScalarWhereInput>;
  NOT?: Maybe<ImageFileScalarWhereInput[] | ImageFileScalarWhereInput>;
}

export interface ImageUseCreateOneInput {
  create?: Maybe<ImageUseCreateInput>;
  connect?: Maybe<ImageUseWhereUniqueInput>;
}

export interface ImageFileUpdateWithWhereUniqueNestedInput {
  where: ImageFileWhereUniqueInput;
  data: ImageFileUpdateDataInput;
}

export interface ImageUseCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface ImageFileUpdateManyInput {
  create?: Maybe<ImageFileCreateInput[] | ImageFileCreateInput>;
  update?: Maybe<
    | ImageFileUpdateWithWhereUniqueNestedInput[]
    | ImageFileUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ImageFileUpsertWithWhereUniqueNestedInput[]
    | ImageFileUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ImageFileWhereUniqueInput[] | ImageFileWhereUniqueInput>;
  connect?: Maybe<ImageFileWhereUniqueInput[] | ImageFileWhereUniqueInput>;
  set?: Maybe<ImageFileWhereUniqueInput[] | ImageFileWhereUniqueInput>;
  disconnect?: Maybe<ImageFileWhereUniqueInput[] | ImageFileWhereUniqueInput>;
  deleteMany?: Maybe<ImageFileScalarWhereInput[] | ImageFileScalarWhereInput>;
  updateMany?: Maybe<
    | ImageFileUpdateManyWithWhereNestedInput[]
    | ImageFileUpdateManyWithWhereNestedInput
  >;
}

export interface ImageFileUpdateInput {
  language?: Maybe<LanguageUpdateOneInput>;
  dimensions?: Maybe<DimensionsUpdateOneInput>;
  alt?: Maybe<String>;
  longdesc?: Maybe<String>;
  caption?: Maybe<String>;
  filename?: Maybe<String>;
  filetype?: Maybe<String>;
  filesize?: Maybe<Float>;
  use?: Maybe<ImageUseUpdateOneInput>;
  md5?: Maybe<String>;
  url?: Maybe<String>;
}

export interface TeamWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  organization?: Maybe<String>;
  organization_not?: Maybe<String>;
  organization_in?: Maybe<String[] | String>;
  organization_not_in?: Maybe<String[] | String>;
  organization_lt?: Maybe<String>;
  organization_lte?: Maybe<String>;
  organization_gt?: Maybe<String>;
  organization_gte?: Maybe<String>;
  organization_contains?: Maybe<String>;
  organization_not_contains?: Maybe<String>;
  organization_starts_with?: Maybe<String>;
  organization_not_starts_with?: Maybe<String>;
  organization_ends_with?: Maybe<String>;
  organization_not_ends_with?: Maybe<String>;
  members_every?: Maybe<UserWhereInput>;
  members_some?: Maybe<UserWhereInput>;
  members_none?: Maybe<UserWhereInput>;
  isConfirmed?: Maybe<Boolean>;
  isConfirmed_not?: Maybe<Boolean>;
  AND?: Maybe<TeamWhereInput[] | TeamWhereInput>;
  OR?: Maybe<TeamWhereInput[] | TeamWhereInput>;
  NOT?: Maybe<TeamWhereInput[] | TeamWhereInput>;
}

export interface LanguageUpdateOneInput {
  create?: Maybe<LanguageCreateInput>;
  update?: Maybe<LanguageUpdateDataInput>;
  upsert?: Maybe<LanguageUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<LanguageWhereUniqueInput>;
}

export interface SupportFileUpdateManyWithWhereNestedInput {
  where: SupportFileScalarWhereInput;
  data: SupportFileUpdateManyDataInput;
}

export interface DimensionsUpdateOneInput {
  create?: Maybe<DimensionsCreateInput>;
  update?: Maybe<DimensionsUpdateDataInput>;
  upsert?: Maybe<DimensionsUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<DimensionsWhereUniqueInput>;
}

export interface SupportFileScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  md5?: Maybe<String>;
  md5_not?: Maybe<String>;
  md5_in?: Maybe<String[] | String>;
  md5_not_in?: Maybe<String[] | String>;
  md5_lt?: Maybe<String>;
  md5_lte?: Maybe<String>;
  md5_gt?: Maybe<String>;
  md5_gte?: Maybe<String>;
  md5_contains?: Maybe<String>;
  md5_not_contains?: Maybe<String>;
  md5_starts_with?: Maybe<String>;
  md5_not_starts_with?: Maybe<String>;
  md5_ends_with?: Maybe<String>;
  md5_not_ends_with?: Maybe<String>;
  filename?: Maybe<String>;
  filename_not?: Maybe<String>;
  filename_in?: Maybe<String[] | String>;
  filename_not_in?: Maybe<String[] | String>;
  filename_lt?: Maybe<String>;
  filename_lte?: Maybe<String>;
  filename_gt?: Maybe<String>;
  filename_gte?: Maybe<String>;
  filename_contains?: Maybe<String>;
  filename_not_contains?: Maybe<String>;
  filename_starts_with?: Maybe<String>;
  filename_not_starts_with?: Maybe<String>;
  filename_ends_with?: Maybe<String>;
  filename_not_ends_with?: Maybe<String>;
  filetype?: Maybe<String>;
  filetype_not?: Maybe<String>;
  filetype_in?: Maybe<String[] | String>;
  filetype_not_in?: Maybe<String[] | String>;
  filetype_lt?: Maybe<String>;
  filetype_lte?: Maybe<String>;
  filetype_gt?: Maybe<String>;
  filetype_gte?: Maybe<String>;
  filetype_contains?: Maybe<String>;
  filetype_not_contains?: Maybe<String>;
  filetype_starts_with?: Maybe<String>;
  filetype_not_starts_with?: Maybe<String>;
  filetype_ends_with?: Maybe<String>;
  filetype_not_ends_with?: Maybe<String>;
  filesize?: Maybe<Float>;
  filesize_not?: Maybe<Float>;
  filesize_in?: Maybe<Float[] | Float>;
  filesize_not_in?: Maybe<Float[] | Float>;
  filesize_lt?: Maybe<Float>;
  filesize_lte?: Maybe<Float>;
  filesize_gt?: Maybe<Float>;
  filesize_gte?: Maybe<Float>;
  AND?: Maybe<SupportFileScalarWhereInput[] | SupportFileScalarWhereInput>;
  OR?: Maybe<SupportFileScalarWhereInput[] | SupportFileScalarWhereInput>;
  NOT?: Maybe<SupportFileScalarWhereInput[] | SupportFileScalarWhereInput>;
}

export interface DimensionsUpdateDataInput {
  width?: Maybe<Int>;
  height?: Maybe<Int>;
}

export interface SupportFileUpsertWithWhereUniqueNestedInput {
  where: SupportFileWhereUniqueInput;
  update: SupportFileUpdateDataInput;
  create: SupportFileCreateInput;
}

export interface DimensionsUpsertNestedInput {
  update: DimensionsUpdateDataInput;
  create: DimensionsCreateInput;
}

export interface SupportFileUpdateWithWhereUniqueNestedInput {
  where: SupportFileWhereUniqueInput;
  data: SupportFileUpdateDataInput;
}

export interface ImageUseUpdateOneInput {
  create?: Maybe<ImageUseCreateInput>;
  update?: Maybe<ImageUseUpdateDataInput>;
  upsert?: Maybe<ImageUseUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ImageUseWhereUniqueInput>;
}

export interface SupportFileUpdateManyInput {
  create?: Maybe<SupportFileCreateInput[] | SupportFileCreateInput>;
  update?: Maybe<
    | SupportFileUpdateWithWhereUniqueNestedInput[]
    | SupportFileUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | SupportFileUpsertWithWhereUniqueNestedInput[]
    | SupportFileUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<SupportFileWhereUniqueInput[] | SupportFileWhereUniqueInput>;
  connect?: Maybe<SupportFileWhereUniqueInput[] | SupportFileWhereUniqueInput>;
  set?: Maybe<SupportFileWhereUniqueInput[] | SupportFileWhereUniqueInput>;
  disconnect?: Maybe<
    SupportFileWhereUniqueInput[] | SupportFileWhereUniqueInput
  >;
  deleteMany?: Maybe<
    SupportFileScalarWhereInput[] | SupportFileScalarWhereInput
  >;
  updateMany?: Maybe<
    | SupportFileUpdateManyWithWhereNestedInput[]
    | SupportFileUpdateManyWithWhereNestedInput
  >;
}

export interface ImageUseUpdateDataInput {
  name?: Maybe<String>;
}

export interface ThumbnailWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  size?: Maybe<ThumbnailSize>;
  size_not?: Maybe<ThumbnailSize>;
  size_in?: Maybe<ThumbnailSize[] | ThumbnailSize>;
  size_not_in?: Maybe<ThumbnailSize[] | ThumbnailSize>;
  image?: Maybe<ImageFileWhereInput>;
  AND?: Maybe<ThumbnailWhereInput[] | ThumbnailWhereInput>;
  OR?: Maybe<ThumbnailWhereInput[] | ThumbnailWhereInput>;
  NOT?: Maybe<ThumbnailWhereInput[] | ThumbnailWhereInput>;
}

export interface ImageUseUpsertNestedInput {
  update: ImageUseUpdateDataInput;
  create: ImageUseCreateInput;
}

export interface VideoUnitScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  descPublic?: Maybe<String>;
  descPublic_not?: Maybe<String>;
  descPublic_in?: Maybe<String[] | String>;
  descPublic_not_in?: Maybe<String[] | String>;
  descPublic_lt?: Maybe<String>;
  descPublic_lte?: Maybe<String>;
  descPublic_gt?: Maybe<String>;
  descPublic_gte?: Maybe<String>;
  descPublic_contains?: Maybe<String>;
  descPublic_not_contains?: Maybe<String>;
  descPublic_starts_with?: Maybe<String>;
  descPublic_not_starts_with?: Maybe<String>;
  descPublic_ends_with?: Maybe<String>;
  descPublic_not_ends_with?: Maybe<String>;
  AND?: Maybe<VideoUnitScalarWhereInput[] | VideoUnitScalarWhereInput>;
  OR?: Maybe<VideoUnitScalarWhereInput[] | VideoUnitScalarWhereInput>;
  NOT?: Maybe<VideoUnitScalarWhereInput[] | VideoUnitScalarWhereInput>;
}

export interface ImageFileUpdateManyMutationInput {
  alt?: Maybe<String>;
  longdesc?: Maybe<String>;
  caption?: Maybe<String>;
  filename?: Maybe<String>;
  filetype?: Maybe<String>;
  filesize?: Maybe<Float>;
  md5?: Maybe<String>;
  url?: Maybe<String>;
}

export interface ThumbnailUpdateManyDataInput {
  size?: Maybe<ThumbnailSize>;
}

export interface ImageUseUpdateInput {
  name?: Maybe<String>;
}

export interface ThumbnailUpdateManyWithWhereNestedInput {
  where: ThumbnailScalarWhereInput;
  data: ThumbnailUpdateManyDataInput;
}

export interface ImageUseUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ThumbnailUpsertWithWhereUniqueNestedInput {
  where: ThumbnailWhereUniqueInput;
  update: ThumbnailUpdateDataInput;
  create: ThumbnailCreateInput;
}

export interface LanguageUpdateInput {
  languageCode?: Maybe<String>;
  locale?: Maybe<String>;
  textDirection?: Maybe<TextDirection>;
  displayName?: Maybe<String>;
  nativeName?: Maybe<String>;
}

export interface ThumbnailUpdateDataInput {
  size?: Maybe<ThumbnailSize>;
  image?: Maybe<ImageFileUpdateOneInput>;
}

export interface LanguageUpdateManyMutationInput {
  languageCode?: Maybe<String>;
  locale?: Maybe<String>;
  textDirection?: Maybe<TextDirection>;
  displayName?: Maybe<String>;
  nativeName?: Maybe<String>;
}

export interface ThumbnailUpdateManyInput {
  create?: Maybe<ThumbnailCreateInput[] | ThumbnailCreateInput>;
  update?: Maybe<
    | ThumbnailUpdateWithWhereUniqueNestedInput[]
    | ThumbnailUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ThumbnailUpsertWithWhereUniqueNestedInput[]
    | ThumbnailUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ThumbnailWhereUniqueInput[] | ThumbnailWhereUniqueInput>;
  connect?: Maybe<ThumbnailWhereUniqueInput[] | ThumbnailWhereUniqueInput>;
  set?: Maybe<ThumbnailWhereUniqueInput[] | ThumbnailWhereUniqueInput>;
  disconnect?: Maybe<ThumbnailWhereUniqueInput[] | ThumbnailWhereUniqueInput>;
  deleteMany?: Maybe<ThumbnailScalarWhereInput[] | ThumbnailScalarWhereInput>;
  updateMany?: Maybe<
    | ThumbnailUpdateManyWithWhereNestedInput[]
    | ThumbnailUpdateManyWithWhereNestedInput
  >;
}

export interface LanguageTranslationUpdateInput {
  name?: Maybe<String>;
  language?: Maybe<LanguageUpdateOneRequiredInput>;
}

export interface VideoStreamWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  site?: Maybe<String>;
  site_not?: Maybe<String>;
  site_in?: Maybe<String[] | String>;
  site_not_in?: Maybe<String[] | String>;
  site_lt?: Maybe<String>;
  site_lte?: Maybe<String>;
  site_gt?: Maybe<String>;
  site_gte?: Maybe<String>;
  site_contains?: Maybe<String>;
  site_not_contains?: Maybe<String>;
  site_starts_with?: Maybe<String>;
  site_not_starts_with?: Maybe<String>;
  site_ends_with?: Maybe<String>;
  site_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  embedUrl?: Maybe<String>;
  embedUrl_not?: Maybe<String>;
  embedUrl_in?: Maybe<String[] | String>;
  embedUrl_not_in?: Maybe<String[] | String>;
  embedUrl_lt?: Maybe<String>;
  embedUrl_lte?: Maybe<String>;
  embedUrl_gt?: Maybe<String>;
  embedUrl_gte?: Maybe<String>;
  embedUrl_contains?: Maybe<String>;
  embedUrl_not_contains?: Maybe<String>;
  embedUrl_starts_with?: Maybe<String>;
  embedUrl_not_starts_with?: Maybe<String>;
  embedUrl_ends_with?: Maybe<String>;
  embedUrl_not_ends_with?: Maybe<String>;
  AND?: Maybe<VideoStreamWhereInput[] | VideoStreamWhereInput>;
  OR?: Maybe<VideoStreamWhereInput[] | VideoStreamWhereInput>;
  NOT?: Maybe<VideoStreamWhereInput[] | VideoStreamWhereInput>;
}

export interface LanguageTranslationUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface CategoryUpdateDataInput {
  translations?: Maybe<LanguageTranslationUpdateManyInput>;
}

export interface SupportFileCreateInput {
  id?: Maybe<ID_Input>;
  language: LanguageCreateOneInput;
  url?: Maybe<String>;
  md5?: Maybe<String>;
  filename?: Maybe<String>;
  filetype?: Maybe<String>;
  filesize?: Maybe<Float>;
  use?: Maybe<SupportFileUseCreateOneInput>;
}

export interface VideoUseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<VideoUseWhereInput[] | VideoUseWhereInput>;
  OR?: Maybe<VideoUseWhereInput[] | VideoUseWhereInput>;
  NOT?: Maybe<VideoUseWhereInput[] | VideoUseWhereInput>;
}

export interface SupportFileUseCreateOneInput {
  create?: Maybe<SupportFileUseCreateInput>;
  connect?: Maybe<SupportFileUseWhereUniqueInput>;
}

export interface CategoryUpdateWithWhereUniqueNestedInput {
  where: CategoryWhereUniqueInput;
  data: CategoryUpdateDataInput;
}

export interface VideoProjectUpdateInput {
  projectType?: Maybe<ProjectType>;
  projectTitle?: Maybe<String>;
  descPublic?: Maybe<String>;
  descInternal?: Maybe<String>;
  author?: Maybe<UserUpdateOneInput>;
  team?: Maybe<TeamUpdateOneInput>;
  status?: Maybe<ProjectPublishStatus>;
  visibility?: Maybe<ProjectVisibility>;
  protectImages?: Maybe<Boolean>;
  units?: Maybe<VideoUnitUpdateManyInput>;
  supportFiles?: Maybe<SupportFileUpdateManyInput>;
  thumbnails?: Maybe<ImageFileUpdateManyInput>;
  categories?: Maybe<CategoryUpdateManyInput>;
  tags?: Maybe<TagUpdateManyInput>;
}

export interface TagScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  OR?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  NOT?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
}

export interface SupportFileUpdateInput {
  language?: Maybe<LanguageUpdateOneRequiredInput>;
  url?: Maybe<String>;
  md5?: Maybe<String>;
  filename?: Maybe<String>;
  filetype?: Maybe<String>;
  filesize?: Maybe<Float>;
  use?: Maybe<SupportFileUseUpdateOneInput>;
}

export interface TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  update: TagUpdateDataInput;
  create: TagCreateInput;
}

export interface SupportFileUseUpdateOneInput {
  create?: Maybe<SupportFileUseCreateInput>;
  update?: Maybe<SupportFileUseUpdateDataInput>;
  upsert?: Maybe<SupportFileUseUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<SupportFileUseWhereUniqueInput>;
}

export interface TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  data: TagUpdateDataInput;
}

export interface SupportFileUseUpdateDataInput {
  name?: Maybe<String>;
}

export interface VideoUnitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  language?: Maybe<LanguageWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  descPublic?: Maybe<String>;
  descPublic_not?: Maybe<String>;
  descPublic_in?: Maybe<String[] | String>;
  descPublic_not_in?: Maybe<String[] | String>;
  descPublic_lt?: Maybe<String>;
  descPublic_lte?: Maybe<String>;
  descPublic_gt?: Maybe<String>;
  descPublic_gte?: Maybe<String>;
  descPublic_contains?: Maybe<String>;
  descPublic_not_contains?: Maybe<String>;
  descPublic_starts_with?: Maybe<String>;
  descPublic_not_starts_with?: Maybe<String>;
  descPublic_ends_with?: Maybe<String>;
  descPublic_not_ends_with?: Maybe<String>;
  files_every?: Maybe<VideoFileWhereInput>;
  files_some?: Maybe<VideoFileWhereInput>;
  files_none?: Maybe<VideoFileWhereInput>;
  tags_every?: Maybe<TagWhereInput>;
  tags_some?: Maybe<TagWhereInput>;
  tags_none?: Maybe<TagWhereInput>;
  categories_every?: Maybe<CategoryWhereInput>;
  categories_some?: Maybe<CategoryWhereInput>;
  categories_none?: Maybe<CategoryWhereInput>;
  thumbnails_every?: Maybe<ThumbnailWhereInput>;
  thumbnails_some?: Maybe<ThumbnailWhereInput>;
  thumbnails_none?: Maybe<ThumbnailWhereInput>;
  AND?: Maybe<VideoUnitWhereInput[] | VideoUnitWhereInput>;
  OR?: Maybe<VideoUnitWhereInput[] | VideoUnitWhereInput>;
  NOT?: Maybe<VideoUnitWhereInput[] | VideoUnitWhereInput>;
}

export interface SupportFileUseUpsertNestedInput {
  update: SupportFileUseUpdateDataInput;
  create: SupportFileUseCreateInput;
}

export interface VideoFileUpdateManyDataInput {
  filetype?: Maybe<String>;
  filename?: Maybe<String>;
  quality?: Maybe<VideoQuality>;
  videoBurnedInStatus?: Maybe<VideoBurnedInStatus>;
  url?: Maybe<String>;
  md5?: Maybe<String>;
  duration?: Maybe<Float>;
  bitrate?: Maybe<Float>;
  filesize?: Maybe<Float>;
}

export interface SupportFileUpdateManyMutationInput {
  url?: Maybe<String>;
  md5?: Maybe<String>;
  filename?: Maybe<String>;
  filetype?: Maybe<String>;
  filesize?: Maybe<Float>;
}

export interface VideoFileUpdateManyWithWhereNestedInput {
  where: VideoFileScalarWhereInput;
  data: VideoFileUpdateManyDataInput;
}

export interface SupportFileUseUpdateInput {
  name?: Maybe<String>;
}

export interface VideoFileUpsertWithWhereUniqueNestedInput {
  where: VideoFileWhereUniqueInput;
  update: VideoFileUpdateDataInput;
  create: VideoFileCreateInput;
}

export interface SupportFileUseUpdateManyMutationInput {
  name?: Maybe<String>;
}

export type VideoStreamWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TagCreateInput {
  id?: Maybe<ID_Input>;
  translations?: Maybe<LanguageTranslationCreateManyInput>;
}

export interface VideoFileUpdateManyInput {
  create?: Maybe<VideoFileCreateInput[] | VideoFileCreateInput>;
  update?: Maybe<
    | VideoFileUpdateWithWhereUniqueNestedInput[]
    | VideoFileUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | VideoFileUpsertWithWhereUniqueNestedInput[]
    | VideoFileUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<VideoFileWhereUniqueInput[] | VideoFileWhereUniqueInput>;
  connect?: Maybe<VideoFileWhereUniqueInput[] | VideoFileWhereUniqueInput>;
  set?: Maybe<VideoFileWhereUniqueInput[] | VideoFileWhereUniqueInput>;
  disconnect?: Maybe<VideoFileWhereUniqueInput[] | VideoFileWhereUniqueInput>;
  deleteMany?: Maybe<VideoFileScalarWhereInput[] | VideoFileScalarWhereInput>;
  updateMany?: Maybe<
    | VideoFileUpdateManyWithWhereNestedInput[]
    | VideoFileUpdateManyWithWhereNestedInput
  >;
}

export interface TagUpdateInput {
  translations?: Maybe<LanguageTranslationUpdateManyInput>;
}

export type VideoUnitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TeamCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  organization: String;
  members?: Maybe<UserCreateManyWithoutTeamInput>;
  contentTypes?: Maybe<TeamCreatecontentTypesInput>;
  isConfirmed?: Maybe<Boolean>;
}

export interface VideoUnitUpdateManyInput {
  create?: Maybe<VideoUnitCreateInput[] | VideoUnitCreateInput>;
  update?: Maybe<
    | VideoUnitUpdateWithWhereUniqueNestedInput[]
    | VideoUnitUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | VideoUnitUpsertWithWhereUniqueNestedInput[]
    | VideoUnitUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<VideoUnitWhereUniqueInput[] | VideoUnitWhereUniqueInput>;
  connect?: Maybe<VideoUnitWhereUniqueInput[] | VideoUnitWhereUniqueInput>;
  set?: Maybe<VideoUnitWhereUniqueInput[] | VideoUnitWhereUniqueInput>;
  disconnect?: Maybe<VideoUnitWhereUniqueInput[] | VideoUnitWhereUniqueInput>;
  deleteMany?: Maybe<VideoUnitScalarWhereInput[] | VideoUnitScalarWhereInput>;
  updateMany?: Maybe<
    | VideoUnitUpdateManyWithWhereNestedInput[]
    | VideoUnitUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateManyWithoutTeamInput {
  create?: Maybe<UserCreateWithoutTeamInput[] | UserCreateWithoutTeamInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export type VideoUseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface UserCreateWithoutTeamInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  email: String;
  password?: Maybe<String>;
  tempToken?: Maybe<String>;
  tempTokenExpiry?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  country?: Maybe<String>;
  city?: Maybe<String>;
  howHeard?: Maybe<String>;
  permissions?: Maybe<UserCreatepermissionsInput>;
  isConfirmed?: Maybe<Boolean>;
}

export interface TeamUpdateDataInput {
  name?: Maybe<String>;
  organization?: Maybe<String>;
  members?: Maybe<UserUpdateManyWithoutTeamInput>;
  contentTypes?: Maybe<TeamUpdatecontentTypesInput>;
  isConfirmed?: Maybe<Boolean>;
}

export interface UserCreatepermissionsInput {
  set?: Maybe<Permission[] | Permission>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface TeamCreatecontentTypesInput {
  set?: Maybe<ContentType[] | ContentType>;
}

export interface CategoryCreateInput {
  id?: Maybe<ID_Input>;
  translations?: Maybe<LanguageTranslationCreateManyInput>;
}

export interface ImageFileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  language?: Maybe<LanguageWhereInput>;
  dimensions?: Maybe<DimensionsWhereInput>;
  alt?: Maybe<String>;
  alt_not?: Maybe<String>;
  alt_in?: Maybe<String[] | String>;
  alt_not_in?: Maybe<String[] | String>;
  alt_lt?: Maybe<String>;
  alt_lte?: Maybe<String>;
  alt_gt?: Maybe<String>;
  alt_gte?: Maybe<String>;
  alt_contains?: Maybe<String>;
  alt_not_contains?: Maybe<String>;
  alt_starts_with?: Maybe<String>;
  alt_not_starts_with?: Maybe<String>;
  alt_ends_with?: Maybe<String>;
  alt_not_ends_with?: Maybe<String>;
  longdesc?: Maybe<String>;
  longdesc_not?: Maybe<String>;
  longdesc_in?: Maybe<String[] | String>;
  longdesc_not_in?: Maybe<String[] | String>;
  longdesc_lt?: Maybe<String>;
  longdesc_lte?: Maybe<String>;
  longdesc_gt?: Maybe<String>;
  longdesc_gte?: Maybe<String>;
  longdesc_contains?: Maybe<String>;
  longdesc_not_contains?: Maybe<String>;
  longdesc_starts_with?: Maybe<String>;
  longdesc_not_starts_with?: Maybe<String>;
  longdesc_ends_with?: Maybe<String>;
  longdesc_not_ends_with?: Maybe<String>;
  caption?: Maybe<String>;
  caption_not?: Maybe<String>;
  caption_in?: Maybe<String[] | String>;
  caption_not_in?: Maybe<String[] | String>;
  caption_lt?: Maybe<String>;
  caption_lte?: Maybe<String>;
  caption_gt?: Maybe<String>;
  caption_gte?: Maybe<String>;
  caption_contains?: Maybe<String>;
  caption_not_contains?: Maybe<String>;
  caption_starts_with?: Maybe<String>;
  caption_not_starts_with?: Maybe<String>;
  caption_ends_with?: Maybe<String>;
  caption_not_ends_with?: Maybe<String>;
  filename?: Maybe<String>;
  filename_not?: Maybe<String>;
  filename_in?: Maybe<String[] | String>;
  filename_not_in?: Maybe<String[] | String>;
  filename_lt?: Maybe<String>;
  filename_lte?: Maybe<String>;
  filename_gt?: Maybe<String>;
  filename_gte?: Maybe<String>;
  filename_contains?: Maybe<String>;
  filename_not_contains?: Maybe<String>;
  filename_starts_with?: Maybe<String>;
  filename_not_starts_with?: Maybe<String>;
  filename_ends_with?: Maybe<String>;
  filename_not_ends_with?: Maybe<String>;
  filetype?: Maybe<String>;
  filetype_not?: Maybe<String>;
  filetype_in?: Maybe<String[] | String>;
  filetype_not_in?: Maybe<String[] | String>;
  filetype_lt?: Maybe<String>;
  filetype_lte?: Maybe<String>;
  filetype_gt?: Maybe<String>;
  filetype_gte?: Maybe<String>;
  filetype_contains?: Maybe<String>;
  filetype_not_contains?: Maybe<String>;
  filetype_starts_with?: Maybe<String>;
  filetype_not_starts_with?: Maybe<String>;
  filetype_ends_with?: Maybe<String>;
  filetype_not_ends_with?: Maybe<String>;
  filesize?: Maybe<Float>;
  filesize_not?: Maybe<Float>;
  filesize_in?: Maybe<Float[] | Float>;
  filesize_not_in?: Maybe<Float[] | Float>;
  filesize_lt?: Maybe<Float>;
  filesize_lte?: Maybe<Float>;
  filesize_gt?: Maybe<Float>;
  filesize_gte?: Maybe<Float>;
  use?: Maybe<ImageUseWhereInput>;
  md5?: Maybe<String>;
  md5_not?: Maybe<String>;
  md5_in?: Maybe<String[] | String>;
  md5_not_in?: Maybe<String[] | String>;
  md5_lt?: Maybe<String>;
  md5_lte?: Maybe<String>;
  md5_gt?: Maybe<String>;
  md5_gte?: Maybe<String>;
  md5_contains?: Maybe<String>;
  md5_not_contains?: Maybe<String>;
  md5_starts_with?: Maybe<String>;
  md5_not_starts_with?: Maybe<String>;
  md5_ends_with?: Maybe<String>;
  md5_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<ImageFileWhereInput[] | ImageFileWhereInput>;
  OR?: Maybe<ImageFileWhereInput[] | ImageFileWhereInput>;
  NOT?: Maybe<ImageFileWhereInput[] | ImageFileWhereInput>;
}

export interface ImageUseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ImageUseWhereInput[] | ImageUseWhereInput>;
  OR?: Maybe<ImageUseWhereInput[] | ImageUseWhereInput>;
  NOT?: Maybe<ImageUseWhereInput[] | ImageUseWhereInput>;
}

export interface UserUpdateManyWithoutTeamInput {
  create?: Maybe<UserCreateWithoutTeamInput[] | UserCreateWithoutTeamInput>;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutTeamInput[]
    | UserUpdateWithWhereUniqueWithoutTeamInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutTeamInput[]
    | UserUpsertWithWhereUniqueWithoutTeamInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface VideoProjectSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VideoProjectWhereInput>;
  AND?: Maybe<
    VideoProjectSubscriptionWhereInput[] | VideoProjectSubscriptionWhereInput
  >;
  OR?: Maybe<
    VideoProjectSubscriptionWhereInput[] | VideoProjectSubscriptionWhereInput
  >;
  NOT?: Maybe<
    VideoProjectSubscriptionWhereInput[] | VideoProjectSubscriptionWhereInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutTeamInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutTeamDataInput;
}

export interface ThumbnailSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ThumbnailWhereInput>;
  AND?: Maybe<
    ThumbnailSubscriptionWhereInput[] | ThumbnailSubscriptionWhereInput
  >;
  OR?: Maybe<
    ThumbnailSubscriptionWhereInput[] | ThumbnailSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ThumbnailSubscriptionWhereInput[] | ThumbnailSubscriptionWhereInput
  >;
}

export interface UserUpdateWithoutTeamDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  tempToken?: Maybe<String>;
  tempTokenExpiry?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  country?: Maybe<String>;
  city?: Maybe<String>;
  howHeard?: Maybe<String>;
  permissions?: Maybe<UserUpdatepermissionsInput>;
  isConfirmed?: Maybe<Boolean>;
}

export interface SupportFileUseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SupportFileUseWhereInput>;
  AND?: Maybe<
    | SupportFileUseSubscriptionWhereInput[]
    | SupportFileUseSubscriptionWhereInput
  >;
  OR?: Maybe<
    | SupportFileUseSubscriptionWhereInput[]
    | SupportFileUseSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | SupportFileUseSubscriptionWhereInput[]
    | SupportFileUseSubscriptionWhereInput
  >;
}

export interface UserUpdatepermissionsInput {
  set?: Maybe<Permission[] | Permission>;
}

export interface LanguageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LanguageWhereInput>;
  AND?: Maybe<
    LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput
  >;
  OR?: Maybe<LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput>;
  NOT?: Maybe<
    LanguageSubscriptionWhereInput[] | LanguageSubscriptionWhereInput
  >;
}

export interface UserUpsertWithWhereUniqueWithoutTeamInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutTeamDataInput;
  create: UserCreateWithoutTeamInput;
}

export interface DimensionsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DimensionsWhereInput>;
  AND?: Maybe<
    DimensionsSubscriptionWhereInput[] | DimensionsSubscriptionWhereInput
  >;
  OR?: Maybe<
    DimensionsSubscriptionWhereInput[] | DimensionsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    DimensionsSubscriptionWhereInput[] | DimensionsSubscriptionWhereInput
  >;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  tempToken?: Maybe<String>;
  tempToken_not?: Maybe<String>;
  tempToken_in?: Maybe<String[] | String>;
  tempToken_not_in?: Maybe<String[] | String>;
  tempToken_lt?: Maybe<String>;
  tempToken_lte?: Maybe<String>;
  tempToken_gt?: Maybe<String>;
  tempToken_gte?: Maybe<String>;
  tempToken_contains?: Maybe<String>;
  tempToken_not_contains?: Maybe<String>;
  tempToken_starts_with?: Maybe<String>;
  tempToken_not_starts_with?: Maybe<String>;
  tempToken_ends_with?: Maybe<String>;
  tempToken_not_ends_with?: Maybe<String>;
  tempTokenExpiry?: Maybe<Float>;
  tempTokenExpiry_not?: Maybe<Float>;
  tempTokenExpiry_in?: Maybe<Float[] | Float>;
  tempTokenExpiry_not_in?: Maybe<Float[] | Float>;
  tempTokenExpiry_lt?: Maybe<Float>;
  tempTokenExpiry_lte?: Maybe<Float>;
  tempTokenExpiry_gt?: Maybe<Float>;
  tempTokenExpiry_gte?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  jobTitle_not?: Maybe<String>;
  jobTitle_in?: Maybe<String[] | String>;
  jobTitle_not_in?: Maybe<String[] | String>;
  jobTitle_lt?: Maybe<String>;
  jobTitle_lte?: Maybe<String>;
  jobTitle_gt?: Maybe<String>;
  jobTitle_gte?: Maybe<String>;
  jobTitle_contains?: Maybe<String>;
  jobTitle_not_contains?: Maybe<String>;
  jobTitle_starts_with?: Maybe<String>;
  jobTitle_not_starts_with?: Maybe<String>;
  jobTitle_ends_with?: Maybe<String>;
  jobTitle_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  howHeard?: Maybe<String>;
  howHeard_not?: Maybe<String>;
  howHeard_in?: Maybe<String[] | String>;
  howHeard_not_in?: Maybe<String[] | String>;
  howHeard_lt?: Maybe<String>;
  howHeard_lte?: Maybe<String>;
  howHeard_gt?: Maybe<String>;
  howHeard_gte?: Maybe<String>;
  howHeard_contains?: Maybe<String>;
  howHeard_not_contains?: Maybe<String>;
  howHeard_starts_with?: Maybe<String>;
  howHeard_not_starts_with?: Maybe<String>;
  howHeard_ends_with?: Maybe<String>;
  howHeard_not_ends_with?: Maybe<String>;
  isConfirmed?: Maybe<Boolean>;
  isConfirmed_not?: Maybe<Boolean>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export type ImageFileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export type SupportFileUseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface UserUpdateManyDataInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  tempToken?: Maybe<String>;
  tempTokenExpiry?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  country?: Maybe<String>;
  city?: Maybe<String>;
  howHeard?: Maybe<String>;
  permissions?: Maybe<UserUpdatepermissionsInput>;
  isConfirmed?: Maybe<Boolean>;
}

export interface VideoProjectUpdateManyMutationInput {
  projectType?: Maybe<ProjectType>;
  projectTitle?: Maybe<String>;
  descPublic?: Maybe<String>;
  descInternal?: Maybe<String>;
  status?: Maybe<ProjectPublishStatus>;
  visibility?: Maybe<ProjectVisibility>;
  protectImages?: Maybe<Boolean>;
}

export interface TeamUpdatecontentTypesInput {
  set?: Maybe<ContentType[] | ContentType>;
}

export interface ImageFileUpdateManyWithWhereNestedInput {
  where: ImageFileScalarWhereInput;
  data: ImageFileUpdateManyDataInput;
}

export interface TeamUpdateManyMutationInput {
  name?: Maybe<String>;
  organization?: Maybe<String>;
  contentTypes?: Maybe<TeamUpdatecontentTypesInput>;
  isConfirmed?: Maybe<Boolean>;
}

export type TeamWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface ThumbnailCreateInput {
  id?: Maybe<ID_Input>;
  size?: Maybe<ThumbnailSize>;
  image?: Maybe<ImageFileCreateOneInput>;
}

export interface SupportFileUpdateManyDataInput {
  url?: Maybe<String>;
  md5?: Maybe<String>;
  filename?: Maybe<String>;
  filetype?: Maybe<String>;
  filesize?: Maybe<Float>;
}

export interface ImageFileCreateOneInput {
  create?: Maybe<ImageFileCreateInput>;
  connect?: Maybe<ImageFileWhereUniqueInput>;
}

export type DimensionsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ThumbnailUpdateInput {
  size?: Maybe<ThumbnailSize>;
  image?: Maybe<ImageFileUpdateOneInput>;
}

export type ThumbnailWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ImageFileUpdateOneInput {
  create?: Maybe<ImageFileCreateInput>;
  update?: Maybe<ImageFileUpdateDataInput>;
  upsert?: Maybe<ImageFileUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ImageFileWhereUniqueInput>;
}

export interface VideoUnitUpdateManyWithWhereNestedInput {
  where: VideoUnitScalarWhereInput;
  data: VideoUnitUpdateManyDataInput;
}

export interface ImageFileUpdateDataInput {
  language?: Maybe<LanguageUpdateOneInput>;
  dimensions?: Maybe<DimensionsUpdateOneInput>;
  alt?: Maybe<String>;
  longdesc?: Maybe<String>;
  caption?: Maybe<String>;
  filename?: Maybe<String>;
  filetype?: Maybe<String>;
  filesize?: Maybe<Float>;
  use?: Maybe<ImageUseUpdateOneInput>;
  md5?: Maybe<String>;
  url?: Maybe<String>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface ImageFileUpsertNestedInput {
  update: ImageFileUpdateDataInput;
  create: ImageFileCreateInput;
}

export type VideoFileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ThumbnailUpdateManyMutationInput {
  size?: Maybe<ThumbnailSize>;
}

export interface CategoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  AND?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  OR?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
  NOT?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  lastName: String;
  email: String;
  password?: Maybe<String>;
  tempToken?: Maybe<String>;
  tempTokenExpiry?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  country?: Maybe<String>;
  city?: Maybe<String>;
  howHeard?: Maybe<String>;
  permissions?: Maybe<UserCreatepermissionsInput>;
  team?: Maybe<TeamCreateOneWithoutMembersInput>;
  isConfirmed?: Maybe<Boolean>;
}

export interface VideoFileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  language?: Maybe<LanguageWhereInput>;
  filetype?: Maybe<String>;
  filetype_not?: Maybe<String>;
  filetype_in?: Maybe<String[] | String>;
  filetype_not_in?: Maybe<String[] | String>;
  filetype_lt?: Maybe<String>;
  filetype_lte?: Maybe<String>;
  filetype_gt?: Maybe<String>;
  filetype_gte?: Maybe<String>;
  filetype_contains?: Maybe<String>;
  filetype_not_contains?: Maybe<String>;
  filetype_starts_with?: Maybe<String>;
  filetype_not_starts_with?: Maybe<String>;
  filetype_ends_with?: Maybe<String>;
  filetype_not_ends_with?: Maybe<String>;
  filename?: Maybe<String>;
  filename_not?: Maybe<String>;
  filename_in?: Maybe<String[] | String>;
  filename_not_in?: Maybe<String[] | String>;
  filename_lt?: Maybe<String>;
  filename_lte?: Maybe<String>;
  filename_gt?: Maybe<String>;
  filename_gte?: Maybe<String>;
  filename_contains?: Maybe<String>;
  filename_not_contains?: Maybe<String>;
  filename_starts_with?: Maybe<String>;
  filename_not_starts_with?: Maybe<String>;
  filename_ends_with?: Maybe<String>;
  filename_not_ends_with?: Maybe<String>;
  use?: Maybe<VideoUseWhereInput>;
  quality?: Maybe<VideoQuality>;
  quality_not?: Maybe<VideoQuality>;
  quality_in?: Maybe<VideoQuality[] | VideoQuality>;
  quality_not_in?: Maybe<VideoQuality[] | VideoQuality>;
  videoBurnedInStatus?: Maybe<VideoBurnedInStatus>;
  videoBurnedInStatus_not?: Maybe<VideoBurnedInStatus>;
  videoBurnedInStatus_in?: Maybe<VideoBurnedInStatus[] | VideoBurnedInStatus>;
  videoBurnedInStatus_not_in?: Maybe<
    VideoBurnedInStatus[] | VideoBurnedInStatus
  >;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  md5?: Maybe<String>;
  md5_not?: Maybe<String>;
  md5_in?: Maybe<String[] | String>;
  md5_not_in?: Maybe<String[] | String>;
  md5_lt?: Maybe<String>;
  md5_lte?: Maybe<String>;
  md5_gt?: Maybe<String>;
  md5_gte?: Maybe<String>;
  md5_contains?: Maybe<String>;
  md5_not_contains?: Maybe<String>;
  md5_starts_with?: Maybe<String>;
  md5_not_starts_with?: Maybe<String>;
  md5_ends_with?: Maybe<String>;
  md5_not_ends_with?: Maybe<String>;
  duration?: Maybe<Float>;
  duration_not?: Maybe<Float>;
  duration_in?: Maybe<Float[] | Float>;
  duration_not_in?: Maybe<Float[] | Float>;
  duration_lt?: Maybe<Float>;
  duration_lte?: Maybe<Float>;
  duration_gt?: Maybe<Float>;
  duration_gte?: Maybe<Float>;
  bitrate?: Maybe<Float>;
  bitrate_not?: Maybe<Float>;
  bitrate_in?: Maybe<Float[] | Float>;
  bitrate_not_in?: Maybe<Float[] | Float>;
  bitrate_lt?: Maybe<Float>;
  bitrate_lte?: Maybe<Float>;
  bitrate_gt?: Maybe<Float>;
  bitrate_gte?: Maybe<Float>;
  filesize?: Maybe<Float>;
  filesize_not?: Maybe<Float>;
  filesize_in?: Maybe<Float[] | Float>;
  filesize_not_in?: Maybe<Float[] | Float>;
  filesize_lt?: Maybe<Float>;
  filesize_lte?: Maybe<Float>;
  filesize_gt?: Maybe<Float>;
  filesize_gte?: Maybe<Float>;
  dimensions?: Maybe<DimensionsWhereInput>;
  stream_every?: Maybe<VideoStreamWhereInput>;
  stream_some?: Maybe<VideoStreamWhereInput>;
  stream_none?: Maybe<VideoStreamWhereInput>;
  AND?: Maybe<VideoFileWhereInput[] | VideoFileWhereInput>;
  OR?: Maybe<VideoFileWhereInput[] | VideoFileWhereInput>;
  NOT?: Maybe<VideoFileWhereInput[] | VideoFileWhereInput>;
}

export interface TeamCreateOneWithoutMembersInput {
  create?: Maybe<TeamCreateWithoutMembersInput>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface CategoryUpdateManyInput {
  create?: Maybe<CategoryCreateInput[] | CategoryCreateInput>;
  update?: Maybe<
    | CategoryUpdateWithWhereUniqueNestedInput[]
    | CategoryUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | CategoryUpsertWithWhereUniqueNestedInput[]
    | CategoryUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  connect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  set?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  disconnect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
  deleteMany?: Maybe<CategoryScalarWhereInput[] | CategoryScalarWhereInput>;
}

export interface TeamCreateWithoutMembersInput {
  id?: Maybe<ID_Input>;
  name: String;
  organization: String;
  contentTypes?: Maybe<TeamCreatecontentTypesInput>;
  isConfirmed?: Maybe<Boolean>;
}

export interface TagUpdateDataInput {
  translations?: Maybe<LanguageTranslationUpdateManyInput>;
}

export interface UserUpdateInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  tempToken?: Maybe<String>;
  tempTokenExpiry?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  country?: Maybe<String>;
  city?: Maybe<String>;
  howHeard?: Maybe<String>;
  permissions?: Maybe<UserUpdatepermissionsInput>;
  team?: Maybe<TeamUpdateOneWithoutMembersInput>;
  isConfirmed?: Maybe<Boolean>;
}

export interface LanguageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  languageCode?: Maybe<String>;
  languageCode_not?: Maybe<String>;
  languageCode_in?: Maybe<String[] | String>;
  languageCode_not_in?: Maybe<String[] | String>;
  languageCode_lt?: Maybe<String>;
  languageCode_lte?: Maybe<String>;
  languageCode_gt?: Maybe<String>;
  languageCode_gte?: Maybe<String>;
  languageCode_contains?: Maybe<String>;
  languageCode_not_contains?: Maybe<String>;
  languageCode_starts_with?: Maybe<String>;
  languageCode_not_starts_with?: Maybe<String>;
  languageCode_ends_with?: Maybe<String>;
  languageCode_not_ends_with?: Maybe<String>;
  locale?: Maybe<String>;
  locale_not?: Maybe<String>;
  locale_in?: Maybe<String[] | String>;
  locale_not_in?: Maybe<String[] | String>;
  locale_lt?: Maybe<String>;
  locale_lte?: Maybe<String>;
  locale_gt?: Maybe<String>;
  locale_gte?: Maybe<String>;
  locale_contains?: Maybe<String>;
  locale_not_contains?: Maybe<String>;
  locale_starts_with?: Maybe<String>;
  locale_not_starts_with?: Maybe<String>;
  locale_ends_with?: Maybe<String>;
  locale_not_ends_with?: Maybe<String>;
  textDirection?: Maybe<TextDirection>;
  textDirection_not?: Maybe<TextDirection>;
  textDirection_in?: Maybe<TextDirection[] | TextDirection>;
  textDirection_not_in?: Maybe<TextDirection[] | TextDirection>;
  displayName?: Maybe<String>;
  displayName_not?: Maybe<String>;
  displayName_in?: Maybe<String[] | String>;
  displayName_not_in?: Maybe<String[] | String>;
  displayName_lt?: Maybe<String>;
  displayName_lte?: Maybe<String>;
  displayName_gt?: Maybe<String>;
  displayName_gte?: Maybe<String>;
  displayName_contains?: Maybe<String>;
  displayName_not_contains?: Maybe<String>;
  displayName_starts_with?: Maybe<String>;
  displayName_not_starts_with?: Maybe<String>;
  displayName_ends_with?: Maybe<String>;
  displayName_not_ends_with?: Maybe<String>;
  nativeName?: Maybe<String>;
  nativeName_not?: Maybe<String>;
  nativeName_in?: Maybe<String[] | String>;
  nativeName_not_in?: Maybe<String[] | String>;
  nativeName_lt?: Maybe<String>;
  nativeName_lte?: Maybe<String>;
  nativeName_gt?: Maybe<String>;
  nativeName_gte?: Maybe<String>;
  nativeName_contains?: Maybe<String>;
  nativeName_not_contains?: Maybe<String>;
  nativeName_starts_with?: Maybe<String>;
  nativeName_not_starts_with?: Maybe<String>;
  nativeName_ends_with?: Maybe<String>;
  nativeName_not_ends_with?: Maybe<String>;
  AND?: Maybe<LanguageWhereInput[] | LanguageWhereInput>;
  OR?: Maybe<LanguageWhereInput[] | LanguageWhereInput>;
  NOT?: Maybe<LanguageWhereInput[] | LanguageWhereInput>;
}

export interface TeamUpdateOneWithoutMembersInput {
  create?: Maybe<TeamCreateWithoutMembersInput>;
  update?: Maybe<TeamUpdateWithoutMembersDataInput>;
  upsert?: Maybe<TeamUpsertWithoutMembersInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface VideoFileScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  filetype?: Maybe<String>;
  filetype_not?: Maybe<String>;
  filetype_in?: Maybe<String[] | String>;
  filetype_not_in?: Maybe<String[] | String>;
  filetype_lt?: Maybe<String>;
  filetype_lte?: Maybe<String>;
  filetype_gt?: Maybe<String>;
  filetype_gte?: Maybe<String>;
  filetype_contains?: Maybe<String>;
  filetype_not_contains?: Maybe<String>;
  filetype_starts_with?: Maybe<String>;
  filetype_not_starts_with?: Maybe<String>;
  filetype_ends_with?: Maybe<String>;
  filetype_not_ends_with?: Maybe<String>;
  filename?: Maybe<String>;
  filename_not?: Maybe<String>;
  filename_in?: Maybe<String[] | String>;
  filename_not_in?: Maybe<String[] | String>;
  filename_lt?: Maybe<String>;
  filename_lte?: Maybe<String>;
  filename_gt?: Maybe<String>;
  filename_gte?: Maybe<String>;
  filename_contains?: Maybe<String>;
  filename_not_contains?: Maybe<String>;
  filename_starts_with?: Maybe<String>;
  filename_not_starts_with?: Maybe<String>;
  filename_ends_with?: Maybe<String>;
  filename_not_ends_with?: Maybe<String>;
  quality?: Maybe<VideoQuality>;
  quality_not?: Maybe<VideoQuality>;
  quality_in?: Maybe<VideoQuality[] | VideoQuality>;
  quality_not_in?: Maybe<VideoQuality[] | VideoQuality>;
  videoBurnedInStatus?: Maybe<VideoBurnedInStatus>;
  videoBurnedInStatus_not?: Maybe<VideoBurnedInStatus>;
  videoBurnedInStatus_in?: Maybe<VideoBurnedInStatus[] | VideoBurnedInStatus>;
  videoBurnedInStatus_not_in?: Maybe<
    VideoBurnedInStatus[] | VideoBurnedInStatus
  >;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  md5?: Maybe<String>;
  md5_not?: Maybe<String>;
  md5_in?: Maybe<String[] | String>;
  md5_not_in?: Maybe<String[] | String>;
  md5_lt?: Maybe<String>;
  md5_lte?: Maybe<String>;
  md5_gt?: Maybe<String>;
  md5_gte?: Maybe<String>;
  md5_contains?: Maybe<String>;
  md5_not_contains?: Maybe<String>;
  md5_starts_with?: Maybe<String>;
  md5_not_starts_with?: Maybe<String>;
  md5_ends_with?: Maybe<String>;
  md5_not_ends_with?: Maybe<String>;
  duration?: Maybe<Float>;
  duration_not?: Maybe<Float>;
  duration_in?: Maybe<Float[] | Float>;
  duration_not_in?: Maybe<Float[] | Float>;
  duration_lt?: Maybe<Float>;
  duration_lte?: Maybe<Float>;
  duration_gt?: Maybe<Float>;
  duration_gte?: Maybe<Float>;
  bitrate?: Maybe<Float>;
  bitrate_not?: Maybe<Float>;
  bitrate_in?: Maybe<Float[] | Float>;
  bitrate_not_in?: Maybe<Float[] | Float>;
  bitrate_lt?: Maybe<Float>;
  bitrate_lte?: Maybe<Float>;
  bitrate_gt?: Maybe<Float>;
  bitrate_gte?: Maybe<Float>;
  filesize?: Maybe<Float>;
  filesize_not?: Maybe<Float>;
  filesize_in?: Maybe<Float[] | Float>;
  filesize_not_in?: Maybe<Float[] | Float>;
  filesize_lt?: Maybe<Float>;
  filesize_lte?: Maybe<Float>;
  filesize_gt?: Maybe<Float>;
  filesize_gte?: Maybe<Float>;
  AND?: Maybe<VideoFileScalarWhereInput[] | VideoFileScalarWhereInput>;
  OR?: Maybe<VideoFileScalarWhereInput[] | VideoFileScalarWhereInput>;
  NOT?: Maybe<VideoFileScalarWhereInput[] | VideoFileScalarWhereInput>;
}

export interface TeamUpdateWithoutMembersDataInput {
  name?: Maybe<String>;
  organization?: Maybe<String>;
  contentTypes?: Maybe<TeamUpdatecontentTypesInput>;
  isConfirmed?: Maybe<Boolean>;
}

export interface VideoFileUpdateWithWhereUniqueNestedInput {
  where: VideoFileWhereUniqueInput;
  data: VideoFileUpdateDataInput;
}

export interface TeamUpsertWithoutMembersInput {
  update: TeamUpdateWithoutMembersDataInput;
  create: TeamCreateWithoutMembersInput;
}

export interface VideoUnitUpdateWithWhereUniqueNestedInput {
  where: VideoUnitWhereUniqueInput;
  data: VideoUnitUpdateDataInput;
}

export interface UserUpdateManyMutationInput {
  firstName?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  tempToken?: Maybe<String>;
  tempTokenExpiry?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  country?: Maybe<String>;
  city?: Maybe<String>;
  howHeard?: Maybe<String>;
  permissions?: Maybe<UserUpdatepermissionsInput>;
  isConfirmed?: Maybe<Boolean>;
}

export interface LanguageTranslationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  language?: Maybe<LanguageWhereInput>;
  AND?: Maybe<LanguageTranslationWhereInput[] | LanguageTranslationWhereInput>;
  OR?: Maybe<LanguageTranslationWhereInput[] | LanguageTranslationWhereInput>;
  NOT?: Maybe<LanguageTranslationWhereInput[] | LanguageTranslationWhereInput>;
}

export interface VideoFileCreateInput {
  id?: Maybe<ID_Input>;
  language?: Maybe<LanguageCreateOneInput>;
  filetype?: Maybe<String>;
  filename?: Maybe<String>;
  use?: Maybe<VideoUseCreateOneInput>;
  quality?: Maybe<VideoQuality>;
  videoBurnedInStatus?: Maybe<VideoBurnedInStatus>;
  url?: Maybe<String>;
  md5?: Maybe<String>;
  duration?: Maybe<Float>;
  bitrate?: Maybe<Float>;
  filesize?: Maybe<Float>;
  dimensions?: Maybe<DimensionsCreateOneInput>;
  stream?: Maybe<VideoStreamCreateManyInput>;
}

export interface VideoUnitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VideoUnitWhereInput>;
  AND?: Maybe<
    VideoUnitSubscriptionWhereInput[] | VideoUnitSubscriptionWhereInput
  >;
  OR?: Maybe<
    VideoUnitSubscriptionWhereInput[] | VideoUnitSubscriptionWhereInput
  >;
  NOT?: Maybe<
    VideoUnitSubscriptionWhereInput[] | VideoUnitSubscriptionWhereInput
  >;
}

export interface VideoUseCreateOneInput {
  create?: Maybe<VideoUseCreateInput>;
  connect?: Maybe<VideoUseWhereUniqueInput>;
}

export type LanguageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  locale?: Maybe<String>;
}>;

export interface VideoUseCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface ImageFileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ImageFileWhereInput>;
  AND?: Maybe<
    ImageFileSubscriptionWhereInput[] | ImageFileSubscriptionWhereInput
  >;
  OR?: Maybe<
    ImageFileSubscriptionWhereInput[] | ImageFileSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ImageFileSubscriptionWhereInput[] | ImageFileSubscriptionWhereInput
  >;
}

export interface VideoStreamCreateManyInput {
  create?: Maybe<VideoStreamCreateInput[] | VideoStreamCreateInput>;
  connect?: Maybe<VideoStreamWhereUniqueInput[] | VideoStreamWhereUniqueInput>;
}

export interface VideoUseUpdateInput {
  name?: Maybe<String>;
}

export interface VideoStreamCreateInput {
  id?: Maybe<ID_Input>;
  site?: Maybe<String>;
  url?: Maybe<String>;
  embedUrl?: Maybe<String>;
}

export interface ImageFileUpdateManyDataInput {
  alt?: Maybe<String>;
  longdesc?: Maybe<String>;
  caption?: Maybe<String>;
  filename?: Maybe<String>;
  filetype?: Maybe<String>;
  filesize?: Maybe<Float>;
  md5?: Maybe<String>;
  url?: Maybe<String>;
}

export interface VideoFileUpdateInput {
  language?: Maybe<LanguageUpdateOneInput>;
  filetype?: Maybe<String>;
  filename?: Maybe<String>;
  use?: Maybe<VideoUseUpdateOneInput>;
  quality?: Maybe<VideoQuality>;
  videoBurnedInStatus?: Maybe<VideoBurnedInStatus>;
  url?: Maybe<String>;
  md5?: Maybe<String>;
  duration?: Maybe<Float>;
  bitrate?: Maybe<Float>;
  filesize?: Maybe<Float>;
  dimensions?: Maybe<DimensionsUpdateOneInput>;
  stream?: Maybe<VideoStreamUpdateManyInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  tempToken?: Maybe<String>;
  tempToken_not?: Maybe<String>;
  tempToken_in?: Maybe<String[] | String>;
  tempToken_not_in?: Maybe<String[] | String>;
  tempToken_lt?: Maybe<String>;
  tempToken_lte?: Maybe<String>;
  tempToken_gt?: Maybe<String>;
  tempToken_gte?: Maybe<String>;
  tempToken_contains?: Maybe<String>;
  tempToken_not_contains?: Maybe<String>;
  tempToken_starts_with?: Maybe<String>;
  tempToken_not_starts_with?: Maybe<String>;
  tempToken_ends_with?: Maybe<String>;
  tempToken_not_ends_with?: Maybe<String>;
  tempTokenExpiry?: Maybe<Float>;
  tempTokenExpiry_not?: Maybe<Float>;
  tempTokenExpiry_in?: Maybe<Float[] | Float>;
  tempTokenExpiry_not_in?: Maybe<Float[] | Float>;
  tempTokenExpiry_lt?: Maybe<Float>;
  tempTokenExpiry_lte?: Maybe<Float>;
  tempTokenExpiry_gt?: Maybe<Float>;
  tempTokenExpiry_gte?: Maybe<Float>;
  jobTitle?: Maybe<String>;
  jobTitle_not?: Maybe<String>;
  jobTitle_in?: Maybe<String[] | String>;
  jobTitle_not_in?: Maybe<String[] | String>;
  jobTitle_lt?: Maybe<String>;
  jobTitle_lte?: Maybe<String>;
  jobTitle_gt?: Maybe<String>;
  jobTitle_gte?: Maybe<String>;
  jobTitle_contains?: Maybe<String>;
  jobTitle_not_contains?: Maybe<String>;
  jobTitle_starts_with?: Maybe<String>;
  jobTitle_not_starts_with?: Maybe<String>;
  jobTitle_ends_with?: Maybe<String>;
  jobTitle_not_ends_with?: Maybe<String>;
  country?: Maybe<String>;
  country_not?: Maybe<String>;
  country_in?: Maybe<String[] | String>;
  country_not_in?: Maybe<String[] | String>;
  country_lt?: Maybe<String>;
  country_lte?: Maybe<String>;
  country_gt?: Maybe<String>;
  country_gte?: Maybe<String>;
  country_contains?: Maybe<String>;
  country_not_contains?: Maybe<String>;
  country_starts_with?: Maybe<String>;
  country_not_starts_with?: Maybe<String>;
  country_ends_with?: Maybe<String>;
  country_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  howHeard?: Maybe<String>;
  howHeard_not?: Maybe<String>;
  howHeard_in?: Maybe<String[] | String>;
  howHeard_not_in?: Maybe<String[] | String>;
  howHeard_lt?: Maybe<String>;
  howHeard_lte?: Maybe<String>;
  howHeard_gt?: Maybe<String>;
  howHeard_gte?: Maybe<String>;
  howHeard_contains?: Maybe<String>;
  howHeard_not_contains?: Maybe<String>;
  howHeard_starts_with?: Maybe<String>;
  howHeard_not_starts_with?: Maybe<String>;
  howHeard_ends_with?: Maybe<String>;
  howHeard_not_ends_with?: Maybe<String>;
  team?: Maybe<TeamWhereInput>;
  isConfirmed?: Maybe<Boolean>;
  isConfirmed_not?: Maybe<Boolean>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface VideoUseUpdateOneInput {
  create?: Maybe<VideoUseCreateInput>;
  update?: Maybe<VideoUseUpdateDataInput>;
  upsert?: Maybe<VideoUseUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<VideoUseWhereUniqueInput>;
}

export interface SupportFileUpdateDataInput {
  language?: Maybe<LanguageUpdateOneRequiredInput>;
  url?: Maybe<String>;
  md5?: Maybe<String>;
  filename?: Maybe<String>;
  filetype?: Maybe<String>;
  filesize?: Maybe<Float>;
  use?: Maybe<SupportFileUseUpdateOneInput>;
}

export interface VideoUseUpdateDataInput {
  name?: Maybe<String>;
}

export interface VideoUnitUpsertWithWhereUniqueNestedInput {
  where: VideoUnitWhereUniqueInput;
  update: VideoUnitUpdateDataInput;
  create: VideoUnitCreateInput;
}

export interface VideoUseUpsertNestedInput {
  update: VideoUseUpdateDataInput;
  create: VideoUseCreateInput;
}

export interface ThumbnailUpdateWithWhereUniqueNestedInput {
  where: ThumbnailWhereUniqueInput;
  data: ThumbnailUpdateDataInput;
}

export interface VideoStreamUpdateManyInput {
  create?: Maybe<VideoStreamCreateInput[] | VideoStreamCreateInput>;
  update?: Maybe<
    | VideoStreamUpdateWithWhereUniqueNestedInput[]
    | VideoStreamUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | VideoStreamUpsertWithWhereUniqueNestedInput[]
    | VideoStreamUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<VideoStreamWhereUniqueInput[] | VideoStreamWhereUniqueInput>;
  connect?: Maybe<VideoStreamWhereUniqueInput[] | VideoStreamWhereUniqueInput>;
  set?: Maybe<VideoStreamWhereUniqueInput[] | VideoStreamWhereUniqueInput>;
  disconnect?: Maybe<
    VideoStreamWhereUniqueInput[] | VideoStreamWhereUniqueInput
  >;
  deleteMany?: Maybe<
    VideoStreamScalarWhereInput[] | VideoStreamScalarWhereInput
  >;
  updateMany?: Maybe<
    | VideoStreamUpdateManyWithWhereNestedInput[]
    | VideoStreamUpdateManyWithWhereNestedInput
  >;
}

export interface CategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  translations_every?: Maybe<LanguageTranslationWhereInput>;
  translations_some?: Maybe<LanguageTranslationWhereInput>;
  translations_none?: Maybe<LanguageTranslationWhereInput>;
  AND?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  OR?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
  NOT?: Maybe<CategoryWhereInput[] | CategoryWhereInput>;
}

export interface VideoStreamUpdateWithWhereUniqueNestedInput {
  where: VideoStreamWhereUniqueInput;
  data: VideoStreamUpdateDataInput;
}

export interface TagUpdateManyInput {
  create?: Maybe<TagCreateInput[] | TagCreateInput>;
  update?: Maybe<
    TagUpdateWithWhereUniqueNestedInput[] | TagUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    TagUpsertWithWhereUniqueNestedInput[] | TagUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  set?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  disconnect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  deleteMany?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
}

export interface VideoStreamUpdateDataInput {
  site?: Maybe<String>;
  url?: Maybe<String>;
  embedUrl?: Maybe<String>;
}

export interface VideoFileUpdateDataInput {
  language?: Maybe<LanguageUpdateOneInput>;
  filetype?: Maybe<String>;
  filename?: Maybe<String>;
  use?: Maybe<VideoUseUpdateOneInput>;
  quality?: Maybe<VideoQuality>;
  videoBurnedInStatus?: Maybe<VideoBurnedInStatus>;
  url?: Maybe<String>;
  md5?: Maybe<String>;
  duration?: Maybe<Float>;
  bitrate?: Maybe<Float>;
  filesize?: Maybe<Float>;
  dimensions?: Maybe<DimensionsUpdateOneInput>;
  stream?: Maybe<VideoStreamUpdateManyInput>;
}

export interface VideoStreamUpsertWithWhereUniqueNestedInput {
  where: VideoStreamWhereUniqueInput;
  update: VideoStreamUpdateDataInput;
  create: VideoStreamCreateInput;
}

export interface TeamUpsertNestedInput {
  update: TeamUpdateDataInput;
  create: TeamCreateInput;
}

export interface VideoStreamScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  site?: Maybe<String>;
  site_not?: Maybe<String>;
  site_in?: Maybe<String[] | String>;
  site_not_in?: Maybe<String[] | String>;
  site_lt?: Maybe<String>;
  site_lte?: Maybe<String>;
  site_gt?: Maybe<String>;
  site_gte?: Maybe<String>;
  site_contains?: Maybe<String>;
  site_not_contains?: Maybe<String>;
  site_starts_with?: Maybe<String>;
  site_not_starts_with?: Maybe<String>;
  site_ends_with?: Maybe<String>;
  site_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  embedUrl?: Maybe<String>;
  embedUrl_not?: Maybe<String>;
  embedUrl_in?: Maybe<String[] | String>;
  embedUrl_not_in?: Maybe<String[] | String>;
  embedUrl_lt?: Maybe<String>;
  embedUrl_lte?: Maybe<String>;
  embedUrl_gt?: Maybe<String>;
  embedUrl_gte?: Maybe<String>;
  embedUrl_contains?: Maybe<String>;
  embedUrl_not_contains?: Maybe<String>;
  embedUrl_starts_with?: Maybe<String>;
  embedUrl_not_starts_with?: Maybe<String>;
  embedUrl_ends_with?: Maybe<String>;
  embedUrl_not_ends_with?: Maybe<String>;
  AND?: Maybe<VideoStreamScalarWhereInput[] | VideoStreamScalarWhereInput>;
  OR?: Maybe<VideoStreamScalarWhereInput[] | VideoStreamScalarWhereInput>;
  NOT?: Maybe<VideoStreamScalarWhereInput[] | VideoStreamScalarWhereInput>;
}

export interface LanguageTranslationCreateManyInput {
  create?: Maybe<
    LanguageTranslationCreateInput[] | LanguageTranslationCreateInput
  >;
  connect?: Maybe<
    LanguageTranslationWhereUniqueInput[] | LanguageTranslationWhereUniqueInput
  >;
}

export interface VideoStreamUpdateManyWithWhereNestedInput {
  where: VideoStreamScalarWhereInput;
  data: VideoStreamUpdateManyDataInput;
}

export interface LanguageTranslationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LanguageTranslationWhereInput>;
  AND?: Maybe<
    | LanguageTranslationSubscriptionWhereInput[]
    | LanguageTranslationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | LanguageTranslationSubscriptionWhereInput[]
    | LanguageTranslationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | LanguageTranslationSubscriptionWhereInput[]
    | LanguageTranslationSubscriptionWhereInput
  >;
}

export interface VideoStreamUpdateManyDataInput {
  site?: Maybe<String>;
  url?: Maybe<String>;
  embedUrl?: Maybe<String>;
}

export interface VideoStreamUpdateManyMutationInput {
  site?: Maybe<String>;
  url?: Maybe<String>;
  embedUrl?: Maybe<String>;
}

export interface VideoFileUpdateManyMutationInput {
  filetype?: Maybe<String>;
  filename?: Maybe<String>;
  quality?: Maybe<VideoQuality>;
  videoBurnedInStatus?: Maybe<VideoBurnedInStatus>;
  url?: Maybe<String>;
  md5?: Maybe<String>;
  duration?: Maybe<Float>;
  bitrate?: Maybe<Float>;
  filesize?: Maybe<Float>;
}

export interface DimensionsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  width?: Maybe<Int>;
  width_not?: Maybe<Int>;
  width_in?: Maybe<Int[] | Int>;
  width_not_in?: Maybe<Int[] | Int>;
  width_lt?: Maybe<Int>;
  width_lte?: Maybe<Int>;
  width_gt?: Maybe<Int>;
  width_gte?: Maybe<Int>;
  height?: Maybe<Int>;
  height_not?: Maybe<Int>;
  height_in?: Maybe<Int[] | Int>;
  height_not_in?: Maybe<Int[] | Int>;
  height_lt?: Maybe<Int>;
  height_lte?: Maybe<Int>;
  height_gt?: Maybe<Int>;
  height_gte?: Maybe<Int>;
  AND?: Maybe<DimensionsWhereInput[] | DimensionsWhereInput>;
  OR?: Maybe<DimensionsWhereInput[] | DimensionsWhereInput>;
  NOT?: Maybe<DimensionsWhereInput[] | DimensionsWhereInput>;
}

export interface VideoProjectCreateInput {
  id?: Maybe<ID_Input>;
  projectType?: Maybe<ProjectType>;
  projectTitle: String;
  descPublic?: Maybe<String>;
  descInternal?: Maybe<String>;
  author?: Maybe<UserCreateOneInput>;
  team?: Maybe<TeamCreateOneInput>;
  status?: Maybe<ProjectPublishStatus>;
  visibility?: Maybe<ProjectVisibility>;
  protectImages?: Maybe<Boolean>;
  units?: Maybe<VideoUnitCreateManyInput>;
  supportFiles?: Maybe<SupportFileCreateManyInput>;
  thumbnails?: Maybe<ImageFileCreateManyInput>;
  categories?: Maybe<CategoryCreateManyInput>;
  tags?: Maybe<TagCreateManyInput>;
}

export interface ThumbnailScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  size?: Maybe<ThumbnailSize>;
  size_not?: Maybe<ThumbnailSize>;
  size_in?: Maybe<ThumbnailSize[] | ThumbnailSize>;
  size_not_in?: Maybe<ThumbnailSize[] | ThumbnailSize>;
  AND?: Maybe<ThumbnailScalarWhereInput[] | ThumbnailScalarWhereInput>;
  OR?: Maybe<ThumbnailScalarWhereInput[] | ThumbnailScalarWhereInput>;
  NOT?: Maybe<ThumbnailScalarWhereInput[] | ThumbnailScalarWhereInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type VideoProjectWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TeamCreateOneInput {
  create?: Maybe<TeamCreateInput>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface VideoUnitUpdateDataInput {
  language?: Maybe<LanguageUpdateOneInput>;
  title?: Maybe<String>;
  descPublic?: Maybe<String>;
  files?: Maybe<VideoFileUpdateManyInput>;
  tags?: Maybe<TagUpdateManyInput>;
  categories?: Maybe<CategoryUpdateManyInput>;
  thumbnails?: Maybe<ThumbnailUpdateManyInput>;
}

export interface VideoUnitCreateManyInput {
  create?: Maybe<VideoUnitCreateInput[] | VideoUnitCreateInput>;
  connect?: Maybe<VideoUnitWhereUniqueInput[] | VideoUnitWhereUniqueInput>;
}

export interface VideoFileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<VideoFileWhereInput>;
  AND?: Maybe<
    VideoFileSubscriptionWhereInput[] | VideoFileSubscriptionWhereInput
  >;
  OR?: Maybe<
    VideoFileSubscriptionWhereInput[] | VideoFileSubscriptionWhereInput
  >;
  NOT?: Maybe<
    VideoFileSubscriptionWhereInput[] | VideoFileSubscriptionWhereInput
  >;
}

export interface VideoUnitCreateInput {
  id?: Maybe<ID_Input>;
  language?: Maybe<LanguageCreateOneInput>;
  title: String;
  descPublic?: Maybe<String>;
  files?: Maybe<VideoFileCreateManyInput>;
  tags?: Maybe<TagCreateManyInput>;
  categories?: Maybe<CategoryCreateManyInput>;
  thumbnails?: Maybe<ThumbnailCreateManyInput>;
}

export interface ImageFileUpsertWithWhereUniqueNestedInput {
  where: ImageFileWhereUniqueInput;
  update: ImageFileUpdateDataInput;
  create: ImageFileCreateInput;
}

export interface VideoFileCreateManyInput {
  create?: Maybe<VideoFileCreateInput[] | VideoFileCreateInput>;
  connect?: Maybe<VideoFileWhereUniqueInput[] | VideoFileWhereUniqueInput>;
}

export interface CategoryUpsertWithWhereUniqueNestedInput {
  where: CategoryWhereUniqueInput;
  update: CategoryUpdateDataInput;
  create: CategoryCreateInput;
}

export interface SupportFileCreateManyInput {
  create?: Maybe<SupportFileCreateInput[] | SupportFileCreateInput>;
  connect?: Maybe<SupportFileWhereUniqueInput[] | SupportFileWhereUniqueInput>;
}

export interface ThumbnailCreateManyInput {
  create?: Maybe<ThumbnailCreateInput[] | ThumbnailCreateInput>;
  connect?: Maybe<ThumbnailWhereUniqueInput[] | ThumbnailWhereUniqueInput>;
}

export interface CategoryCreateManyInput {
  create?: Maybe<CategoryCreateInput[] | CategoryCreateInput>;
  connect?: Maybe<CategoryWhereUniqueInput[] | CategoryWhereUniqueInput>;
}

export interface TagCreateManyInput {
  create?: Maybe<TagCreateInput[] | TagCreateInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
}

export interface VideoProjectWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  projectType?: Maybe<ProjectType>;
  projectType_not?: Maybe<ProjectType>;
  projectType_in?: Maybe<ProjectType[] | ProjectType>;
  projectType_not_in?: Maybe<ProjectType[] | ProjectType>;
  projectTitle?: Maybe<String>;
  projectTitle_not?: Maybe<String>;
  projectTitle_in?: Maybe<String[] | String>;
  projectTitle_not_in?: Maybe<String[] | String>;
  projectTitle_lt?: Maybe<String>;
  projectTitle_lte?: Maybe<String>;
  projectTitle_gt?: Maybe<String>;
  projectTitle_gte?: Maybe<String>;
  projectTitle_contains?: Maybe<String>;
  projectTitle_not_contains?: Maybe<String>;
  projectTitle_starts_with?: Maybe<String>;
  projectTitle_not_starts_with?: Maybe<String>;
  projectTitle_ends_with?: Maybe<String>;
  projectTitle_not_ends_with?: Maybe<String>;
  descPublic?: Maybe<String>;
  descPublic_not?: Maybe<String>;
  descPublic_in?: Maybe<String[] | String>;
  descPublic_not_in?: Maybe<String[] | String>;
  descPublic_lt?: Maybe<String>;
  descPublic_lte?: Maybe<String>;
  descPublic_gt?: Maybe<String>;
  descPublic_gte?: Maybe<String>;
  descPublic_contains?: Maybe<String>;
  descPublic_not_contains?: Maybe<String>;
  descPublic_starts_with?: Maybe<String>;
  descPublic_not_starts_with?: Maybe<String>;
  descPublic_ends_with?: Maybe<String>;
  descPublic_not_ends_with?: Maybe<String>;
  descInternal?: Maybe<String>;
  descInternal_not?: Maybe<String>;
  descInternal_in?: Maybe<String[] | String>;
  descInternal_not_in?: Maybe<String[] | String>;
  descInternal_lt?: Maybe<String>;
  descInternal_lte?: Maybe<String>;
  descInternal_gt?: Maybe<String>;
  descInternal_gte?: Maybe<String>;
  descInternal_contains?: Maybe<String>;
  descInternal_not_contains?: Maybe<String>;
  descInternal_starts_with?: Maybe<String>;
  descInternal_not_starts_with?: Maybe<String>;
  descInternal_ends_with?: Maybe<String>;
  descInternal_not_ends_with?: Maybe<String>;
  author?: Maybe<UserWhereInput>;
  team?: Maybe<TeamWhereInput>;
  status?: Maybe<ProjectPublishStatus>;
  status_not?: Maybe<ProjectPublishStatus>;
  status_in?: Maybe<ProjectPublishStatus[] | ProjectPublishStatus>;
  status_not_in?: Maybe<ProjectPublishStatus[] | ProjectPublishStatus>;
  visibility?: Maybe<ProjectVisibility>;
  visibility_not?: Maybe<ProjectVisibility>;
  visibility_in?: Maybe<ProjectVisibility[] | ProjectVisibility>;
  visibility_not_in?: Maybe<ProjectVisibility[] | ProjectVisibility>;
  protectImages?: Maybe<Boolean>;
  protectImages_not?: Maybe<Boolean>;
  units_every?: Maybe<VideoUnitWhereInput>;
  units_some?: Maybe<VideoUnitWhereInput>;
  units_none?: Maybe<VideoUnitWhereInput>;
  supportFiles_every?: Maybe<SupportFileWhereInput>;
  supportFiles_some?: Maybe<SupportFileWhereInput>;
  supportFiles_none?: Maybe<SupportFileWhereInput>;
  thumbnails_every?: Maybe<ImageFileWhereInput>;
  thumbnails_some?: Maybe<ImageFileWhereInput>;
  thumbnails_none?: Maybe<ImageFileWhereInput>;
  categories_every?: Maybe<CategoryWhereInput>;
  categories_some?: Maybe<CategoryWhereInput>;
  categories_none?: Maybe<CategoryWhereInput>;
  tags_every?: Maybe<TagWhereInput>;
  tags_some?: Maybe<TagWhereInput>;
  tags_none?: Maybe<TagWhereInput>;
  AND?: Maybe<VideoProjectWhereInput[] | VideoProjectWhereInput>;
  OR?: Maybe<VideoProjectWhereInput[] | VideoProjectWhereInput>;
  NOT?: Maybe<VideoProjectWhereInput[] | VideoProjectWhereInput>;
}

export interface VideoUnitUpdateManyDataInput {
  title?: Maybe<String>;
  descPublic?: Maybe<String>;
}

export interface SupportFileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  language?: Maybe<LanguageWhereInput>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  md5?: Maybe<String>;
  md5_not?: Maybe<String>;
  md5_in?: Maybe<String[] | String>;
  md5_not_in?: Maybe<String[] | String>;
  md5_lt?: Maybe<String>;
  md5_lte?: Maybe<String>;
  md5_gt?: Maybe<String>;
  md5_gte?: Maybe<String>;
  md5_contains?: Maybe<String>;
  md5_not_contains?: Maybe<String>;
  md5_starts_with?: Maybe<String>;
  md5_not_starts_with?: Maybe<String>;
  md5_ends_with?: Maybe<String>;
  md5_not_ends_with?: Maybe<String>;
  filename?: Maybe<String>;
  filename_not?: Maybe<String>;
  filename_in?: Maybe<String[] | String>;
  filename_not_in?: Maybe<String[] | String>;
  filename_lt?: Maybe<String>;
  filename_lte?: Maybe<String>;
  filename_gt?: Maybe<String>;
  filename_gte?: Maybe<String>;
  filename_contains?: Maybe<String>;
  filename_not_contains?: Maybe<String>;
  filename_starts_with?: Maybe<String>;
  filename_not_starts_with?: Maybe<String>;
  filename_ends_with?: Maybe<String>;
  filename_not_ends_with?: Maybe<String>;
  filetype?: Maybe<String>;
  filetype_not?: Maybe<String>;
  filetype_in?: Maybe<String[] | String>;
  filetype_not_in?: Maybe<String[] | String>;
  filetype_lt?: Maybe<String>;
  filetype_lte?: Maybe<String>;
  filetype_gt?: Maybe<String>;
  filetype_gte?: Maybe<String>;
  filetype_contains?: Maybe<String>;
  filetype_not_contains?: Maybe<String>;
  filetype_starts_with?: Maybe<String>;
  filetype_not_starts_with?: Maybe<String>;
  filetype_ends_with?: Maybe<String>;
  filetype_not_ends_with?: Maybe<String>;
  filesize?: Maybe<Float>;
  filesize_not?: Maybe<Float>;
  filesize_in?: Maybe<Float[] | Float>;
  filesize_not_in?: Maybe<Float[] | Float>;
  filesize_lt?: Maybe<Float>;
  filesize_lte?: Maybe<Float>;
  filesize_gt?: Maybe<Float>;
  filesize_gte?: Maybe<Float>;
  use?: Maybe<SupportFileUseWhereInput>;
  AND?: Maybe<SupportFileWhereInput[] | SupportFileWhereInput>;
  OR?: Maybe<SupportFileWhereInput[] | SupportFileWhereInput>;
  NOT?: Maybe<SupportFileWhereInput[] | SupportFileWhereInput>;
}

export interface TeamUpdateOneInput {
  create?: Maybe<TeamCreateInput>;
  update?: Maybe<TeamUpdateDataInput>;
  upsert?: Maybe<TeamUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<TeamWhereUniqueInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface VideoUsePreviousValues {
  id: ID_Output;
  name: String;
}

export interface VideoUsePreviousValuesPromise
  extends Promise<VideoUsePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface VideoUsePreviousValuesSubscription
  extends Promise<AsyncIterator<VideoUsePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSupportFile {
  count: Int;
}

export interface AggregateSupportFilePromise
  extends Promise<AggregateSupportFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSupportFileSubscription
  extends Promise<AsyncIterator<AggregateSupportFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImageUse {
  id: ID_Output;
  name: String;
}

export interface ImageUsePromise extends Promise<ImageUse>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ImageUseSubscription
  extends Promise<AsyncIterator<ImageUse>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ImageUseNullablePromise
  extends Promise<ImageUse | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SupportFileEdge {
  node: SupportFile;
  cursor: String;
}

export interface SupportFileEdgePromise
  extends Promise<SupportFileEdge>,
    Fragmentable {
  node: <T = SupportFilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SupportFileEdgeSubscription
  extends Promise<AsyncIterator<SupportFileEdge>>,
    Fragmentable {
  node: <T = SupportFileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface SupportFileConnection {
  pageInfo: PageInfo;
  edges: SupportFileEdge[];
}

export interface SupportFileConnectionPromise
  extends Promise<SupportFileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SupportFileEdge>>() => T;
  aggregate: <T = AggregateSupportFilePromise>() => T;
}

export interface SupportFileConnectionSubscription
  extends Promise<AsyncIterator<SupportFileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SupportFileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSupportFileSubscription>() => T;
}

export interface VideoUseEdge {
  node: VideoUse;
  cursor: String;
}

export interface VideoUseEdgePromise
  extends Promise<VideoUseEdge>,
    Fragmentable {
  node: <T = VideoUsePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoUseEdgeSubscription
  extends Promise<AsyncIterator<VideoUseEdge>>,
    Fragmentable {
  node: <T = VideoUseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SupportFileUse {
  id: ID_Output;
  name: String;
}

export interface SupportFileUsePromise
  extends Promise<SupportFileUse>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SupportFileUseSubscription
  extends Promise<AsyncIterator<SupportFileUse>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SupportFileUseNullablePromise
  extends Promise<SupportFileUse | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface AggregateVideoUnit {
  count: Int;
}

export interface AggregateVideoUnitPromise
  extends Promise<AggregateVideoUnit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoUnitSubscription
  extends Promise<AsyncIterator<AggregateVideoUnit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Category {
  id: ID_Output;
}

export interface CategoryPromise extends Promise<Category>, Fragmentable {
  id: () => Promise<ID_Output>;
  translations: <T = FragmentableArray<LanguageTranslation>>(args?: {
    where?: LanguageTranslationWhereInput;
    orderBy?: LanguageTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategorySubscription
  extends Promise<AsyncIterator<Category>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  translations: <
    T = Promise<AsyncIterator<LanguageTranslationSubscription>>
  >(args?: {
    where?: LanguageTranslationWhereInput;
    orderBy?: LanguageTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CategoryNullablePromise
  extends Promise<Category | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  translations: <T = FragmentableArray<LanguageTranslation>>(args?: {
    where?: LanguageTranslationWhereInput;
    orderBy?: LanguageTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface VideoUnitConnection {
  pageInfo: PageInfo;
  edges: VideoUnitEdge[];
}

export interface VideoUnitConnectionPromise
  extends Promise<VideoUnitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoUnitEdge>>() => T;
  aggregate: <T = AggregateVideoUnitPromise>() => T;
}

export interface VideoUnitConnectionSubscription
  extends Promise<AsyncIterator<VideoUnitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VideoUnitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVideoUnitSubscription>() => T;
}

export interface CategorySubscriptionPayload {
  mutation: MutationType;
  node: Category;
  updatedFields: String[];
  previousValues: CategoryPreviousValues;
}

export interface CategorySubscriptionPayloadPromise
  extends Promise<CategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CategoryPreviousValuesPromise>() => T;
}

export interface CategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CategoryPreviousValuesSubscription>() => T;
}

export interface VideoStreamEdge {
  node: VideoStream;
  cursor: String;
}

export interface VideoStreamEdgePromise
  extends Promise<VideoStreamEdge>,
    Fragmentable {
  node: <T = VideoStreamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoStreamEdgeSubscription
  extends Promise<AsyncIterator<VideoStreamEdge>>,
    Fragmentable {
  node: <T = VideoStreamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CategoryPreviousValues {
  id: ID_Output;
}

export interface CategoryPreviousValuesPromise
  extends Promise<CategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface AggregateVideoProject {
  count: Int;
}

export interface AggregateVideoProjectPromise
  extends Promise<AggregateVideoProject>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoProjectSubscription
  extends Promise<AsyncIterator<AggregateVideoProject>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SupportFile {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  url?: String;
  md5?: String;
  filename?: String;
  filetype?: String;
  filesize?: Float;
}

export interface SupportFilePromise extends Promise<SupportFile>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  language: <T = LanguagePromise>() => T;
  url: () => Promise<String>;
  md5: () => Promise<String>;
  filename: () => Promise<String>;
  filetype: () => Promise<String>;
  filesize: () => Promise<Float>;
  use: <T = SupportFileUsePromise>() => T;
}

export interface SupportFileSubscription
  extends Promise<AsyncIterator<SupportFile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  language: <T = LanguageSubscription>() => T;
  url: () => Promise<AsyncIterator<String>>;
  md5: () => Promise<AsyncIterator<String>>;
  filename: () => Promise<AsyncIterator<String>>;
  filetype: () => Promise<AsyncIterator<String>>;
  filesize: () => Promise<AsyncIterator<Float>>;
  use: <T = SupportFileUseSubscription>() => T;
}

export interface SupportFileNullablePromise
  extends Promise<SupportFile | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  language: <T = LanguagePromise>() => T;
  url: () => Promise<String>;
  md5: () => Promise<String>;
  filename: () => Promise<String>;
  filetype: () => Promise<String>;
  filesize: () => Promise<Float>;
  use: <T = SupportFileUsePromise>() => T;
}

export interface VideoProjectConnection {
  pageInfo: PageInfo;
  edges: VideoProjectEdge[];
}

export interface VideoProjectConnectionPromise
  extends Promise<VideoProjectConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoProjectEdge>>() => T;
  aggregate: <T = AggregateVideoProjectPromise>() => T;
}

export interface VideoProjectConnectionSubscription
  extends Promise<AsyncIterator<VideoProjectConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VideoProjectEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVideoProjectSubscription>() => T;
}

export interface DimensionsSubscriptionPayload {
  mutation: MutationType;
  node: Dimensions;
  updatedFields: String[];
  previousValues: DimensionsPreviousValues;
}

export interface DimensionsSubscriptionPayloadPromise
  extends Promise<DimensionsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DimensionsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DimensionsPreviousValuesPromise>() => T;
}

export interface DimensionsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DimensionsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DimensionsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DimensionsPreviousValuesSubscription>() => T;
}

export interface VideoUnit {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  descPublic?: String;
}

export interface VideoUnitPromise extends Promise<VideoUnit>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  language: <T = LanguagePromise>() => T;
  title: () => Promise<String>;
  descPublic: () => Promise<String>;
  files: <T = FragmentableArray<VideoFile>>(args?: {
    where?: VideoFileWhereInput;
    orderBy?: VideoFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  categories: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  thumbnails: <T = FragmentableArray<Thumbnail>>(args?: {
    where?: ThumbnailWhereInput;
    orderBy?: ThumbnailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface VideoUnitSubscription
  extends Promise<AsyncIterator<VideoUnit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  language: <T = LanguageSubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  descPublic: () => Promise<AsyncIterator<String>>;
  files: <T = Promise<AsyncIterator<VideoFileSubscription>>>(args?: {
    where?: VideoFileWhereInput;
    orderBy?: VideoFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  categories: <T = Promise<AsyncIterator<CategorySubscription>>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  thumbnails: <T = Promise<AsyncIterator<ThumbnailSubscription>>>(args?: {
    where?: ThumbnailWhereInput;
    orderBy?: ThumbnailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface VideoUnitNullablePromise
  extends Promise<VideoUnit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  language: <T = LanguagePromise>() => T;
  title: () => Promise<String>;
  descPublic: () => Promise<String>;
  files: <T = FragmentableArray<VideoFile>>(args?: {
    where?: VideoFileWhereInput;
    orderBy?: VideoFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  categories: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  thumbnails: <T = FragmentableArray<Thumbnail>>(args?: {
    where?: ThumbnailWhereInput;
    orderBy?: ThumbnailOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface DimensionsPreviousValues {
  id: ID_Output;
  width?: Int;
  height?: Int;
}

export interface DimensionsPreviousValuesPromise
  extends Promise<DimensionsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  width: () => Promise<Int>;
  height: () => Promise<Int>;
}

export interface DimensionsPreviousValuesSubscription
  extends Promise<AsyncIterator<DimensionsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  width: () => Promise<AsyncIterator<Int>>;
  height: () => Promise<AsyncIterator<Int>>;
}

export interface LanguageTranslation {
  id: ID_Output;
  name: String;
}

export interface LanguageTranslationPromise
  extends Promise<LanguageTranslation>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface LanguageTranslationSubscription
  extends Promise<AsyncIterator<LanguageTranslation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  language: <T = LanguageSubscription>() => T;
}

export interface LanguageTranslationNullablePromise
  extends Promise<LanguageTranslation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  language: <T = LanguagePromise>() => T;
}

export interface AggregateLanguageTranslation {
  count: Int;
}

export interface AggregateLanguageTranslationPromise
  extends Promise<AggregateLanguageTranslation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLanguageTranslationSubscription
  extends Promise<AsyncIterator<AggregateLanguageTranslation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VideoProject {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  projectType: ProjectType;
  projectTitle: String;
  descPublic?: String;
  descInternal?: String;
  status?: ProjectPublishStatus;
  visibility?: ProjectVisibility;
  protectImages?: Boolean;
}

export interface VideoProjectPromise
  extends Promise<VideoProject>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  projectType: () => Promise<ProjectType>;
  projectTitle: () => Promise<String>;
  descPublic: () => Promise<String>;
  descInternal: () => Promise<String>;
  author: <T = UserPromise>() => T;
  team: <T = TeamPromise>() => T;
  status: () => Promise<ProjectPublishStatus>;
  visibility: () => Promise<ProjectVisibility>;
  protectImages: () => Promise<Boolean>;
  units: <T = FragmentableArray<VideoUnit>>(args?: {
    where?: VideoUnitWhereInput;
    orderBy?: VideoUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  supportFiles: <T = FragmentableArray<SupportFile>>(args?: {
    where?: SupportFileWhereInput;
    orderBy?: SupportFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  thumbnails: <T = FragmentableArray<ImageFile>>(args?: {
    where?: ImageFileWhereInput;
    orderBy?: ImageFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  categories: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface VideoProjectSubscription
  extends Promise<AsyncIterator<VideoProject>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  projectType: () => Promise<AsyncIterator<ProjectType>>;
  projectTitle: () => Promise<AsyncIterator<String>>;
  descPublic: () => Promise<AsyncIterator<String>>;
  descInternal: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  team: <T = TeamSubscription>() => T;
  status: () => Promise<AsyncIterator<ProjectPublishStatus>>;
  visibility: () => Promise<AsyncIterator<ProjectVisibility>>;
  protectImages: () => Promise<AsyncIterator<Boolean>>;
  units: <T = Promise<AsyncIterator<VideoUnitSubscription>>>(args?: {
    where?: VideoUnitWhereInput;
    orderBy?: VideoUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  supportFiles: <T = Promise<AsyncIterator<SupportFileSubscription>>>(args?: {
    where?: SupportFileWhereInput;
    orderBy?: SupportFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  thumbnails: <T = Promise<AsyncIterator<ImageFileSubscription>>>(args?: {
    where?: ImageFileWhereInput;
    orderBy?: ImageFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  categories: <T = Promise<AsyncIterator<CategorySubscription>>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface VideoProjectNullablePromise
  extends Promise<VideoProject | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  projectType: () => Promise<ProjectType>;
  projectTitle: () => Promise<String>;
  descPublic: () => Promise<String>;
  descInternal: () => Promise<String>;
  author: <T = UserPromise>() => T;
  team: <T = TeamPromise>() => T;
  status: () => Promise<ProjectPublishStatus>;
  visibility: () => Promise<ProjectVisibility>;
  protectImages: () => Promise<Boolean>;
  units: <T = FragmentableArray<VideoUnit>>(args?: {
    where?: VideoUnitWhereInput;
    orderBy?: VideoUnitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  supportFiles: <T = FragmentableArray<SupportFile>>(args?: {
    where?: SupportFileWhereInput;
    orderBy?: SupportFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  thumbnails: <T = FragmentableArray<ImageFile>>(args?: {
    where?: ImageFileWhereInput;
    orderBy?: ImageFileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  categories: <T = FragmentableArray<Category>>(args?: {
    where?: CategoryWhereInput;
    orderBy?: CategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ImageFileSubscriptionPayload {
  mutation: MutationType;
  node: ImageFile;
  updatedFields: String[];
  previousValues: ImageFilePreviousValues;
}

export interface ImageFileSubscriptionPayloadPromise
  extends Promise<ImageFileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImageFilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImageFilePreviousValuesPromise>() => T;
}

export interface ImageFileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageFileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageFileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImageFilePreviousValuesSubscription>() => T;
}

export interface VideoFileEdge {
  node: VideoFile;
  cursor: String;
}

export interface VideoFileEdgePromise
  extends Promise<VideoFileEdge>,
    Fragmentable {
  node: <T = VideoFilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoFileEdgeSubscription
  extends Promise<AsyncIterator<VideoFileEdge>>,
    Fragmentable {
  node: <T = VideoFileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ImageFilePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  alt?: String;
  longdesc?: String;
  caption?: String;
  filename?: String;
  filetype?: String;
  filesize?: Float;
  md5?: String;
  url?: String;
}

export interface ImageFilePreviousValuesPromise
  extends Promise<ImageFilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  alt: () => Promise<String>;
  longdesc: () => Promise<String>;
  caption: () => Promise<String>;
  filename: () => Promise<String>;
  filetype: () => Promise<String>;
  filesize: () => Promise<Float>;
  md5: () => Promise<String>;
  url: () => Promise<String>;
}

export interface ImageFilePreviousValuesSubscription
  extends Promise<AsyncIterator<ImageFilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  alt: () => Promise<AsyncIterator<String>>;
  longdesc: () => Promise<AsyncIterator<String>>;
  caption: () => Promise<AsyncIterator<String>>;
  filename: () => Promise<AsyncIterator<String>>;
  filetype: () => Promise<AsyncIterator<String>>;
  filesize: () => Promise<AsyncIterator<Float>>;
  md5: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface VideoStream {
  id: ID_Output;
  site?: String;
  url?: String;
  embedUrl?: String;
}

export interface VideoStreamPromise extends Promise<VideoStream>, Fragmentable {
  id: () => Promise<ID_Output>;
  site: () => Promise<String>;
  url: () => Promise<String>;
  embedUrl: () => Promise<String>;
}

export interface VideoStreamSubscription
  extends Promise<AsyncIterator<VideoStream>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  site: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  embedUrl: () => Promise<AsyncIterator<String>>;
}

export interface VideoStreamNullablePromise
  extends Promise<VideoStream | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  site: () => Promise<String>;
  url: () => Promise<String>;
  embedUrl: () => Promise<String>;
}

export interface LanguageTranslationEdge {
  node: LanguageTranslation;
  cursor: String;
}

export interface LanguageTranslationEdgePromise
  extends Promise<LanguageTranslationEdge>,
    Fragmentable {
  node: <T = LanguageTranslationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LanguageTranslationEdgeSubscription
  extends Promise<AsyncIterator<LanguageTranslationEdge>>,
    Fragmentable {
  node: <T = LanguageTranslationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ImageUseSubscriptionPayload {
  mutation: MutationType;
  node: ImageUse;
  updatedFields: String[];
  previousValues: ImageUsePreviousValues;
}

export interface ImageUseSubscriptionPayloadPromise
  extends Promise<ImageUseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImageUsePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImageUsePreviousValuesPromise>() => T;
}

export interface ImageUseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageUseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageUseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImageUsePreviousValuesSubscription>() => T;
}

export interface VideoUse {
  id: ID_Output;
  name: String;
}

export interface VideoUsePromise extends Promise<VideoUse>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface VideoUseSubscription
  extends Promise<AsyncIterator<VideoUse>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface VideoUseNullablePromise
  extends Promise<VideoUse | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ImageUsePreviousValues {
  id: ID_Output;
  name: String;
}

export interface ImageUsePreviousValuesPromise
  extends Promise<ImageUsePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ImageUsePreviousValuesSubscription
  extends Promise<AsyncIterator<ImageUsePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LanguageTranslationConnection {
  pageInfo: PageInfo;
  edges: LanguageTranslationEdge[];
}

export interface LanguageTranslationConnectionPromise
  extends Promise<LanguageTranslationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LanguageTranslationEdge>>() => T;
  aggregate: <T = AggregateLanguageTranslationPromise>() => T;
}

export interface LanguageTranslationConnectionSubscription
  extends Promise<AsyncIterator<LanguageTranslationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<LanguageTranslationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateLanguageTranslationSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface LanguageSubscriptionPayload {
  mutation: MutationType;
  node: Language;
  updatedFields: String[];
  previousValues: LanguagePreviousValues;
}

export interface LanguageSubscriptionPayloadPromise
  extends Promise<LanguageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LanguagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LanguagePreviousValuesPromise>() => T;
}

export interface LanguageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LanguageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LanguageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LanguagePreviousValuesSubscription>() => T;
}

export interface ThumbnailEdge {
  node: Thumbnail;
  cursor: String;
}

export interface ThumbnailEdgePromise
  extends Promise<ThumbnailEdge>,
    Fragmentable {
  node: <T = ThumbnailPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ThumbnailEdgeSubscription
  extends Promise<AsyncIterator<ThumbnailEdge>>,
    Fragmentable {
  node: <T = ThumbnailSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LanguagePreviousValues {
  id: ID_Output;
  languageCode: String;
  locale: String;
  textDirection: TextDirection;
  displayName: String;
  nativeName: String;
}

export interface LanguagePreviousValuesPromise
  extends Promise<LanguagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  languageCode: () => Promise<String>;
  locale: () => Promise<String>;
  textDirection: () => Promise<TextDirection>;
  displayName: () => Promise<String>;
  nativeName: () => Promise<String>;
}

export interface LanguagePreviousValuesSubscription
  extends Promise<AsyncIterator<LanguagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  languageCode: () => Promise<AsyncIterator<String>>;
  locale: () => Promise<AsyncIterator<String>>;
  textDirection: () => Promise<AsyncIterator<TextDirection>>;
  displayName: () => Promise<AsyncIterator<String>>;
  nativeName: () => Promise<AsyncIterator<String>>;
}

export interface CategoryEdge {
  node: Category;
  cursor: String;
}

export interface CategoryEdgePromise
  extends Promise<CategoryEdge>,
    Fragmentable {
  node: <T = CategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CategoryEdgeSubscription
  extends Promise<AsyncIterator<CategoryEdge>>,
    Fragmentable {
  node: <T = CategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLanguage {
  count: Int;
}

export interface AggregateLanguagePromise
  extends Promise<AggregateLanguage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLanguageSubscription
  extends Promise<AsyncIterator<AggregateLanguage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Thumbnail {
  id: ID_Output;
  size?: ThumbnailSize;
}

export interface ThumbnailPromise extends Promise<Thumbnail>, Fragmentable {
  id: () => Promise<ID_Output>;
  size: () => Promise<ThumbnailSize>;
  image: <T = ImageFilePromise>() => T;
}

export interface ThumbnailSubscription
  extends Promise<AsyncIterator<Thumbnail>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  size: () => Promise<AsyncIterator<ThumbnailSize>>;
  image: <T = ImageFileSubscription>() => T;
}

export interface ThumbnailNullablePromise
  extends Promise<Thumbnail | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  size: () => Promise<ThumbnailSize>;
  image: <T = ImageFilePromise>() => T;
}

export interface LanguageTranslationSubscriptionPayload {
  mutation: MutationType;
  node: LanguageTranslation;
  updatedFields: String[];
  previousValues: LanguageTranslationPreviousValues;
}

export interface LanguageTranslationSubscriptionPayloadPromise
  extends Promise<LanguageTranslationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LanguageTranslationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LanguageTranslationPreviousValuesPromise>() => T;
}

export interface LanguageTranslationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LanguageTranslationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LanguageTranslationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LanguageTranslationPreviousValuesSubscription>() => T;
}

export interface TeamEdge {
  node: Team;
  cursor: String;
}

export interface TeamEdgePromise extends Promise<TeamEdge>, Fragmentable {
  node: <T = TeamPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TeamEdgeSubscription
  extends Promise<AsyncIterator<TeamEdge>>,
    Fragmentable {
  node: <T = TeamSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LanguageTranslationPreviousValues {
  id: ID_Output;
  name: String;
}

export interface LanguageTranslationPreviousValuesPromise
  extends Promise<LanguageTranslationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface LanguageTranslationPreviousValuesSubscription
  extends Promise<AsyncIterator<LanguageTranslationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface Dimensions {
  id: ID_Output;
  width?: Int;
  height?: Int;
}

export interface DimensionsPromise extends Promise<Dimensions>, Fragmentable {
  id: () => Promise<ID_Output>;
  width: () => Promise<Int>;
  height: () => Promise<Int>;
}

export interface DimensionsSubscription
  extends Promise<AsyncIterator<Dimensions>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  width: () => Promise<AsyncIterator<Int>>;
  height: () => Promise<AsyncIterator<Int>>;
}

export interface DimensionsNullablePromise
  extends Promise<Dimensions | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  width: () => Promise<Int>;
  height: () => Promise<Int>;
}

export interface LanguageEdge {
  node: Language;
  cursor: String;
}

export interface LanguageEdgePromise
  extends Promise<LanguageEdge>,
    Fragmentable {
  node: <T = LanguagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface LanguageEdgeSubscription
  extends Promise<AsyncIterator<LanguageEdge>>,
    Fragmentable {
  node: <T = LanguageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DimensionsConnection {
  pageInfo: PageInfo;
  edges: DimensionsEdge[];
}

export interface DimensionsConnectionPromise
  extends Promise<DimensionsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DimensionsEdge>>() => T;
  aggregate: <T = AggregateDimensionsPromise>() => T;
}

export interface DimensionsConnectionSubscription
  extends Promise<AsyncIterator<DimensionsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DimensionsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDimensionsSubscription>() => T;
}

export interface SupportFileSubscriptionPayload {
  mutation: MutationType;
  node: SupportFile;
  updatedFields: String[];
  previousValues: SupportFilePreviousValues;
}

export interface SupportFileSubscriptionPayloadPromise
  extends Promise<SupportFileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SupportFilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SupportFilePreviousValuesPromise>() => T;
}

export interface SupportFileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SupportFileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SupportFileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SupportFilePreviousValuesSubscription>() => T;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SupportFilePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  url?: String;
  md5?: String;
  filename?: String;
  filetype?: String;
  filesize?: Float;
}

export interface SupportFilePreviousValuesPromise
  extends Promise<SupportFilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  url: () => Promise<String>;
  md5: () => Promise<String>;
  filename: () => Promise<String>;
  filetype: () => Promise<String>;
  filesize: () => Promise<Float>;
}

export interface SupportFilePreviousValuesSubscription
  extends Promise<AsyncIterator<SupportFilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  url: () => Promise<AsyncIterator<String>>;
  md5: () => Promise<AsyncIterator<String>>;
  filename: () => Promise<AsyncIterator<String>>;
  filetype: () => Promise<AsyncIterator<String>>;
  filesize: () => Promise<AsyncIterator<Float>>;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface LanguageConnection {
  pageInfo: PageInfo;
  edges: LanguageEdge[];
}

export interface LanguageConnectionPromise
  extends Promise<LanguageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LanguageEdge>>() => T;
  aggregate: <T = AggregateLanguagePromise>() => T;
}

export interface LanguageConnectionSubscription
  extends Promise<AsyncIterator<LanguageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LanguageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLanguageSubscription>() => T;
}

export interface Tag {
  id: ID_Output;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  translations: <T = FragmentableArray<LanguageTranslation>>(args?: {
    where?: LanguageTranslationWhereInput;
    orderBy?: LanguageTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  translations: <
    T = Promise<AsyncIterator<LanguageTranslationSubscription>>
  >(args?: {
    where?: LanguageTranslationWhereInput;
    orderBy?: LanguageTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TagNullablePromise extends Promise<Tag | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  translations: <T = FragmentableArray<LanguageTranslation>>(args?: {
    where?: LanguageTranslationWhereInput;
    orderBy?: LanguageTranslationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SupportFileUseSubscriptionPayload {
  mutation: MutationType;
  node: SupportFileUse;
  updatedFields: String[];
  previousValues: SupportFileUsePreviousValues;
}

export interface SupportFileUseSubscriptionPayloadPromise
  extends Promise<SupportFileUseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SupportFileUsePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SupportFileUsePreviousValuesPromise>() => T;
}

export interface SupportFileUseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SupportFileUseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SupportFileUseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SupportFileUsePreviousValuesSubscription>() => T;
}

export interface SupportFileUseEdge {
  node: SupportFileUse;
  cursor: String;
}

export interface SupportFileUseEdgePromise
  extends Promise<SupportFileUseEdge>,
    Fragmentable {
  node: <T = SupportFileUsePromise>() => T;
  cursor: () => Promise<String>;
}

export interface SupportFileUseEdgeSubscription
  extends Promise<AsyncIterator<SupportFileUseEdge>>,
    Fragmentable {
  node: <T = SupportFileUseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SupportFileUsePreviousValues {
  id: ID_Output;
  name: String;
}

export interface SupportFileUsePreviousValuesPromise
  extends Promise<SupportFileUsePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SupportFileUsePreviousValuesSubscription
  extends Promise<AsyncIterator<SupportFileUsePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDimensions {
  count: Int;
}

export interface AggregateDimensionsPromise
  extends Promise<AggregateDimensions>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDimensionsSubscription
  extends Promise<AsyncIterator<AggregateDimensions>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImageFile {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  alt?: String;
  longdesc?: String;
  caption?: String;
  filename?: String;
  filetype?: String;
  filesize?: Float;
  md5?: String;
  url?: String;
}

export interface ImageFilePromise extends Promise<ImageFile>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  language: <T = LanguagePromise>() => T;
  dimensions: <T = DimensionsPromise>() => T;
  alt: () => Promise<String>;
  longdesc: () => Promise<String>;
  caption: () => Promise<String>;
  filename: () => Promise<String>;
  filetype: () => Promise<String>;
  filesize: () => Promise<Float>;
  use: <T = ImageUsePromise>() => T;
  md5: () => Promise<String>;
  url: () => Promise<String>;
}

export interface ImageFileSubscription
  extends Promise<AsyncIterator<ImageFile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  language: <T = LanguageSubscription>() => T;
  dimensions: <T = DimensionsSubscription>() => T;
  alt: () => Promise<AsyncIterator<String>>;
  longdesc: () => Promise<AsyncIterator<String>>;
  caption: () => Promise<AsyncIterator<String>>;
  filename: () => Promise<AsyncIterator<String>>;
  filetype: () => Promise<AsyncIterator<String>>;
  filesize: () => Promise<AsyncIterator<Float>>;
  use: <T = ImageUseSubscription>() => T;
  md5: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface ImageFileNullablePromise
  extends Promise<ImageFile | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  language: <T = LanguagePromise>() => T;
  dimensions: <T = DimensionsPromise>() => T;
  alt: () => Promise<String>;
  longdesc: () => Promise<String>;
  caption: () => Promise<String>;
  filename: () => Promise<String>;
  filetype: () => Promise<String>;
  filesize: () => Promise<Float>;
  use: <T = ImageUsePromise>() => T;
  md5: () => Promise<String>;
  url: () => Promise<String>;
}

export interface AggregateVideoUse {
  count: Int;
}

export interface AggregateVideoUsePromise
  extends Promise<AggregateVideoUse>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoUseSubscription
  extends Promise<AsyncIterator<AggregateVideoUse>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface VideoUnitEdge {
  node: VideoUnit;
  cursor: String;
}

export interface VideoUnitEdgePromise
  extends Promise<VideoUnitEdge>,
    Fragmentable {
  node: <T = VideoUnitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoUnitEdgeSubscription
  extends Promise<AsyncIterator<VideoUnitEdge>>,
    Fragmentable {
  node: <T = VideoUnitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TagPreviousValues {
  id: ID_Output;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface VideoStreamConnection {
  pageInfo: PageInfo;
  edges: VideoStreamEdge[];
}

export interface VideoStreamConnectionPromise
  extends Promise<VideoStreamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoStreamEdge>>() => T;
  aggregate: <T = AggregateVideoStreamPromise>() => T;
}

export interface VideoStreamConnectionSubscription
  extends Promise<AsyncIterator<VideoStreamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VideoStreamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVideoStreamSubscription>() => T;
}

export interface VideoUseConnection {
  pageInfo: PageInfo;
  edges: VideoUseEdge[];
}

export interface VideoUseConnectionPromise
  extends Promise<VideoUseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoUseEdge>>() => T;
  aggregate: <T = AggregateVideoUsePromise>() => T;
}

export interface VideoUseConnectionSubscription
  extends Promise<AsyncIterator<VideoUseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VideoUseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVideoUseSubscription>() => T;
}

export interface VideoStreamPreviousValues {
  id: ID_Output;
  site?: String;
  url?: String;
  embedUrl?: String;
}

export interface VideoStreamPreviousValuesPromise
  extends Promise<VideoStreamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  site: () => Promise<String>;
  url: () => Promise<String>;
  embedUrl: () => Promise<String>;
}

export interface VideoStreamPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoStreamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  site: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  embedUrl: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVideoStream {
  count: Int;
}

export interface AggregateVideoStreamPromise
  extends Promise<AggregateVideoStream>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoStreamSubscription
  extends Promise<AsyncIterator<AggregateVideoStream>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateImageUse {
  count: Int;
}

export interface AggregateImageUsePromise
  extends Promise<AggregateImageUse>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageUseSubscription
  extends Promise<AsyncIterator<AggregateImageUse>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VideoProjectEdge {
  node: VideoProject;
  cursor: String;
}

export interface VideoProjectEdgePromise
  extends Promise<VideoProjectEdge>,
    Fragmentable {
  node: <T = VideoProjectPromise>() => T;
  cursor: () => Promise<String>;
}

export interface VideoProjectEdgeSubscription
  extends Promise<AsyncIterator<VideoProjectEdge>>,
    Fragmentable {
  node: <T = VideoProjectSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateVideoFile {
  count: Int;
}

export interface AggregateVideoFilePromise
  extends Promise<AggregateVideoFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateVideoFileSubscription
  extends Promise<AsyncIterator<AggregateVideoFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VideoUnitSubscriptionPayload {
  mutation: MutationType;
  node: VideoUnit;
  updatedFields: String[];
  previousValues: VideoUnitPreviousValues;
}

export interface VideoUnitSubscriptionPayloadPromise
  extends Promise<VideoUnitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoUnitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoUnitPreviousValuesPromise>() => T;
}

export interface VideoUnitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoUnitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoUnitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoUnitPreviousValuesSubscription>() => T;
}

export interface CategoryConnection {
  pageInfo: PageInfo;
  edges: CategoryEdge[];
}

export interface CategoryConnectionPromise
  extends Promise<CategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CategoryEdge>>() => T;
  aggregate: <T = AggregateCategoryPromise>() => T;
}

export interface CategoryConnectionSubscription
  extends Promise<AsyncIterator<CategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCategorySubscription>() => T;
}

export interface TeamSubscriptionPayload {
  mutation: MutationType;
  node: Team;
  updatedFields: String[];
  previousValues: TeamPreviousValues;
}

export interface TeamSubscriptionPayloadPromise
  extends Promise<TeamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TeamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TeamPreviousValuesPromise>() => T;
}

export interface TeamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TeamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TeamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TeamPreviousValuesSubscription>() => T;
}

export interface VideoFile {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  filetype?: String;
  filename?: String;
  quality?: VideoQuality;
  videoBurnedInStatus?: VideoBurnedInStatus;
  url?: String;
  md5?: String;
  duration?: Float;
  bitrate?: Float;
  filesize?: Float;
}

export interface VideoFilePromise extends Promise<VideoFile>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  language: <T = LanguagePromise>() => T;
  filetype: () => Promise<String>;
  filename: () => Promise<String>;
  use: <T = VideoUsePromise>() => T;
  quality: () => Promise<VideoQuality>;
  videoBurnedInStatus: () => Promise<VideoBurnedInStatus>;
  url: () => Promise<String>;
  md5: () => Promise<String>;
  duration: () => Promise<Float>;
  bitrate: () => Promise<Float>;
  filesize: () => Promise<Float>;
  dimensions: <T = DimensionsPromise>() => T;
  stream: <T = FragmentableArray<VideoStream>>(args?: {
    where?: VideoStreamWhereInput;
    orderBy?: VideoStreamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface VideoFileSubscription
  extends Promise<AsyncIterator<VideoFile>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  language: <T = LanguageSubscription>() => T;
  filetype: () => Promise<AsyncIterator<String>>;
  filename: () => Promise<AsyncIterator<String>>;
  use: <T = VideoUseSubscription>() => T;
  quality: () => Promise<AsyncIterator<VideoQuality>>;
  videoBurnedInStatus: () => Promise<AsyncIterator<VideoBurnedInStatus>>;
  url: () => Promise<AsyncIterator<String>>;
  md5: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Float>>;
  bitrate: () => Promise<AsyncIterator<Float>>;
  filesize: () => Promise<AsyncIterator<Float>>;
  dimensions: <T = DimensionsSubscription>() => T;
  stream: <T = Promise<AsyncIterator<VideoStreamSubscription>>>(args?: {
    where?: VideoStreamWhereInput;
    orderBy?: VideoStreamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface VideoFileNullablePromise
  extends Promise<VideoFile | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  language: <T = LanguagePromise>() => T;
  filetype: () => Promise<String>;
  filename: () => Promise<String>;
  use: <T = VideoUsePromise>() => T;
  quality: () => Promise<VideoQuality>;
  videoBurnedInStatus: () => Promise<VideoBurnedInStatus>;
  url: () => Promise<String>;
  md5: () => Promise<String>;
  duration: () => Promise<Float>;
  bitrate: () => Promise<Float>;
  filesize: () => Promise<Float>;
  dimensions: <T = DimensionsPromise>() => T;
  stream: <T = FragmentableArray<VideoStream>>(args?: {
    where?: VideoStreamWhereInput;
    orderBy?: VideoStreamOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TeamPreviousValues {
  id: ID_Output;
  name: String;
  organization: String;
  contentTypes: ContentType[];
  isConfirmed: Boolean;
}

export interface TeamPreviousValuesPromise
  extends Promise<TeamPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  organization: () => Promise<String>;
  contentTypes: () => Promise<ContentType[]>;
  isConfirmed: () => Promise<Boolean>;
}

export interface TeamPreviousValuesSubscription
  extends Promise<AsyncIterator<TeamPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  organization: () => Promise<AsyncIterator<String>>;
  contentTypes: () => Promise<AsyncIterator<ContentType[]>>;
  isConfirmed: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateThumbnail {
  count: Int;
}

export interface AggregateThumbnailPromise
  extends Promise<AggregateThumbnail>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateThumbnailSubscription
  extends Promise<AsyncIterator<AggregateThumbnail>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImageUseEdge {
  node: ImageUse;
  cursor: String;
}

export interface ImageUseEdgePromise
  extends Promise<ImageUseEdge>,
    Fragmentable {
  node: <T = ImageUsePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageUseEdgeSubscription
  extends Promise<AsyncIterator<ImageUseEdge>>,
    Fragmentable {
  node: <T = ImageUseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCategory {
  count: Int;
}

export interface AggregateCategoryPromise
  extends Promise<AggregateCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCategorySubscription
  extends Promise<AsyncIterator<AggregateCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ThumbnailSubscriptionPayload {
  mutation: MutationType;
  node: Thumbnail;
  updatedFields: String[];
  previousValues: ThumbnailPreviousValues;
}

export interface ThumbnailSubscriptionPayloadPromise
  extends Promise<ThumbnailSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ThumbnailPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ThumbnailPreviousValuesPromise>() => T;
}

export interface ThumbnailSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ThumbnailSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ThumbnailSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ThumbnailPreviousValuesSubscription>() => T;
}

export interface TeamConnection {
  pageInfo: PageInfo;
  edges: TeamEdge[];
}

export interface TeamConnectionPromise
  extends Promise<TeamConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TeamEdge>>() => T;
  aggregate: <T = AggregateTeamPromise>() => T;
}

export interface TeamConnectionSubscription
  extends Promise<AsyncIterator<TeamConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TeamEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTeamSubscription>() => T;
}

export interface ThumbnailPreviousValues {
  id: ID_Output;
  size?: ThumbnailSize;
}

export interface ThumbnailPreviousValuesPromise
  extends Promise<ThumbnailPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  size: () => Promise<ThumbnailSize>;
}

export interface ThumbnailPreviousValuesSubscription
  extends Promise<AsyncIterator<ThumbnailPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  size: () => Promise<AsyncIterator<ThumbnailSize>>;
}

export interface Team {
  id: ID_Output;
  name: String;
  organization: String;
  contentTypes: ContentType[];
  isConfirmed: Boolean;
}

export interface TeamPromise extends Promise<Team>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  organization: () => Promise<String>;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contentTypes: () => Promise<ContentType[]>;
  isConfirmed: () => Promise<Boolean>;
}

export interface TeamSubscription
  extends Promise<AsyncIterator<Team>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  organization: () => Promise<AsyncIterator<String>>;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contentTypes: () => Promise<AsyncIterator<ContentType[]>>;
  isConfirmed: () => Promise<AsyncIterator<Boolean>>;
}

export interface TeamNullablePromise
  extends Promise<Team | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  organization: () => Promise<String>;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  contentTypes: () => Promise<ContentType[]>;
  isConfirmed: () => Promise<Boolean>;
}

export interface ImageUseConnection {
  pageInfo: PageInfo;
  edges: ImageUseEdge[];
}

export interface ImageUseConnectionPromise
  extends Promise<ImageUseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageUseEdge>>() => T;
  aggregate: <T = AggregateImageUsePromise>() => T;
}

export interface ImageUseConnectionSubscription
  extends Promise<AsyncIterator<ImageUseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageUseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageUseSubscription>() => T;
}

export interface DimensionsEdge {
  node: Dimensions;
  cursor: String;
}

export interface DimensionsEdgePromise
  extends Promise<DimensionsEdge>,
    Fragmentable {
  node: <T = DimensionsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DimensionsEdgeSubscription
  extends Promise<AsyncIterator<DimensionsEdge>>,
    Fragmentable {
  node: <T = DimensionsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface SupportFileUseConnection {
  pageInfo: PageInfo;
  edges: SupportFileUseEdge[];
}

export interface SupportFileUseConnectionPromise
  extends Promise<SupportFileUseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SupportFileUseEdge>>() => T;
  aggregate: <T = AggregateSupportFileUsePromise>() => T;
}

export interface SupportFileUseConnectionSubscription
  extends Promise<AsyncIterator<SupportFileUseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SupportFileUseEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSupportFileUseSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  firstName: String;
  lastName: String;
  email: String;
  password?: String;
  tempToken?: String;
  tempTokenExpiry?: Float;
  jobTitle?: String;
  country?: String;
  city?: String;
  howHeard?: String;
  permissions: Permission[];
  isConfirmed: Boolean;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  tempToken: () => Promise<String>;
  tempTokenExpiry: () => Promise<Float>;
  jobTitle: () => Promise<String>;
  country: () => Promise<String>;
  city: () => Promise<String>;
  howHeard: () => Promise<String>;
  permissions: () => Promise<Permission[]>;
  isConfirmed: () => Promise<Boolean>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  tempToken: () => Promise<AsyncIterator<String>>;
  tempTokenExpiry: () => Promise<AsyncIterator<Float>>;
  jobTitle: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  howHeard: () => Promise<AsyncIterator<String>>;
  permissions: () => Promise<AsyncIterator<Permission[]>>;
  isConfirmed: () => Promise<AsyncIterator<Boolean>>;
}

export interface Language {
  id: ID_Output;
  languageCode: String;
  locale: String;
  textDirection: TextDirection;
  displayName: String;
  nativeName: String;
}

export interface LanguagePromise extends Promise<Language>, Fragmentable {
  id: () => Promise<ID_Output>;
  languageCode: () => Promise<String>;
  locale: () => Promise<String>;
  textDirection: () => Promise<TextDirection>;
  displayName: () => Promise<String>;
  nativeName: () => Promise<String>;
}

export interface LanguageSubscription
  extends Promise<AsyncIterator<Language>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  languageCode: () => Promise<AsyncIterator<String>>;
  locale: () => Promise<AsyncIterator<String>>;
  textDirection: () => Promise<AsyncIterator<TextDirection>>;
  displayName: () => Promise<AsyncIterator<String>>;
  nativeName: () => Promise<AsyncIterator<String>>;
}

export interface LanguageNullablePromise
  extends Promise<Language | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  languageCode: () => Promise<String>;
  locale: () => Promise<String>;
  textDirection: () => Promise<TextDirection>;
  displayName: () => Promise<String>;
  nativeName: () => Promise<String>;
}

export interface ImageFileConnection {
  pageInfo: PageInfo;
  edges: ImageFileEdge[];
}

export interface ImageFileConnectionPromise
  extends Promise<ImageFileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageFileEdge>>() => T;
  aggregate: <T = AggregateImageFilePromise>() => T;
}

export interface ImageFileConnectionSubscription
  extends Promise<AsyncIterator<ImageFileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageFileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageFileSubscription>() => T;
}

export interface VideoUseSubscriptionPayload {
  mutation: MutationType;
  node: VideoUse;
  updatedFields: String[];
  previousValues: VideoUsePreviousValues;
}

export interface VideoUseSubscriptionPayloadPromise
  extends Promise<VideoUseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoUsePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoUsePreviousValuesPromise>() => T;
}

export interface VideoUseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoUseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoUseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoUsePreviousValuesSubscription>() => T;
}

export interface VideoFileSubscriptionPayload {
  mutation: MutationType;
  node: VideoFile;
  updatedFields: String[];
  previousValues: VideoFilePreviousValues;
}

export interface VideoFileSubscriptionPayloadPromise
  extends Promise<VideoFileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoFilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoFilePreviousValuesPromise>() => T;
}

export interface VideoFileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoFileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoFileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoFilePreviousValuesSubscription>() => T;
}

export interface ThumbnailConnection {
  pageInfo: PageInfo;
  edges: ThumbnailEdge[];
}

export interface ThumbnailConnectionPromise
  extends Promise<ThumbnailConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ThumbnailEdge>>() => T;
  aggregate: <T = AggregateThumbnailPromise>() => T;
}

export interface ThumbnailConnectionSubscription
  extends Promise<AsyncIterator<ThumbnailConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ThumbnailEdgeSubscription>>>() => T;
  aggregate: <T = AggregateThumbnailSubscription>() => T;
}

export interface VideoFilePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  filetype?: String;
  filename?: String;
  quality?: VideoQuality;
  videoBurnedInStatus?: VideoBurnedInStatus;
  url?: String;
  md5?: String;
  duration?: Float;
  bitrate?: Float;
  filesize?: Float;
}

export interface VideoFilePreviousValuesPromise
  extends Promise<VideoFilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  filetype: () => Promise<String>;
  filename: () => Promise<String>;
  quality: () => Promise<VideoQuality>;
  videoBurnedInStatus: () => Promise<VideoBurnedInStatus>;
  url: () => Promise<String>;
  md5: () => Promise<String>;
  duration: () => Promise<Float>;
  bitrate: () => Promise<Float>;
  filesize: () => Promise<Float>;
}

export interface VideoFilePreviousValuesSubscription
  extends Promise<AsyncIterator<VideoFilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  filetype: () => Promise<AsyncIterator<String>>;
  filename: () => Promise<AsyncIterator<String>>;
  quality: () => Promise<AsyncIterator<VideoQuality>>;
  videoBurnedInStatus: () => Promise<AsyncIterator<VideoBurnedInStatus>>;
  url: () => Promise<AsyncIterator<String>>;
  md5: () => Promise<AsyncIterator<String>>;
  duration: () => Promise<AsyncIterator<Float>>;
  bitrate: () => Promise<AsyncIterator<Float>>;
  filesize: () => Promise<AsyncIterator<Float>>;
}

export interface User {
  id: ID_Output;
  firstName: String;
  lastName: String;
  email: String;
  password?: String;
  tempToken?: String;
  tempTokenExpiry?: Float;
  jobTitle?: String;
  country?: String;
  city?: String;
  howHeard?: String;
  permissions: Permission[];
  isConfirmed: Boolean;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  tempToken: () => Promise<String>;
  tempTokenExpiry: () => Promise<Float>;
  jobTitle: () => Promise<String>;
  country: () => Promise<String>;
  city: () => Promise<String>;
  howHeard: () => Promise<String>;
  permissions: () => Promise<Permission[]>;
  team: <T = TeamPromise>() => T;
  isConfirmed: () => Promise<Boolean>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  tempToken: () => Promise<AsyncIterator<String>>;
  tempTokenExpiry: () => Promise<AsyncIterator<Float>>;
  jobTitle: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  howHeard: () => Promise<AsyncIterator<String>>;
  permissions: () => Promise<AsyncIterator<Permission[]>>;
  team: <T = TeamSubscription>() => T;
  isConfirmed: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  tempToken: () => Promise<String>;
  tempTokenExpiry: () => Promise<Float>;
  jobTitle: () => Promise<String>;
  country: () => Promise<String>;
  city: () => Promise<String>;
  howHeard: () => Promise<String>;
  permissions: () => Promise<Permission[]>;
  team: <T = TeamPromise>() => T;
  isConfirmed: () => Promise<Boolean>;
}

export interface AggregateImageFile {
  count: Int;
}

export interface AggregateImageFilePromise
  extends Promise<AggregateImageFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageFileSubscription
  extends Promise<AsyncIterator<AggregateImageFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateSupportFileUse {
  count: Int;
}

export interface AggregateSupportFileUsePromise
  extends Promise<AggregateSupportFileUse>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSupportFileUseSubscription
  extends Promise<AsyncIterator<AggregateSupportFileUse>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface VideoFileConnection {
  pageInfo: PageInfo;
  edges: VideoFileEdge[];
}

export interface VideoFileConnectionPromise
  extends Promise<VideoFileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<VideoFileEdge>>() => T;
  aggregate: <T = AggregateVideoFilePromise>() => T;
}

export interface VideoFileConnectionSubscription
  extends Promise<AsyncIterator<VideoFileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<VideoFileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateVideoFileSubscription>() => T;
}

export interface VideoStreamSubscriptionPayload {
  mutation: MutationType;
  node: VideoStream;
  updatedFields: String[];
  previousValues: VideoStreamPreviousValues;
}

export interface VideoStreamSubscriptionPayloadPromise
  extends Promise<VideoStreamSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoStreamPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoStreamPreviousValuesPromise>() => T;
}

export interface VideoStreamSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoStreamSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoStreamSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoStreamPreviousValuesSubscription>() => T;
}

export interface ImageFileEdge {
  node: ImageFile;
  cursor: String;
}

export interface ImageFileEdgePromise
  extends Promise<ImageFileEdge>,
    Fragmentable {
  node: <T = ImageFilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageFileEdgeSubscription
  extends Promise<AsyncIterator<ImageFileEdge>>,
    Fragmentable {
  node: <T = ImageFileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface VideoProjectPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  projectType: ProjectType;
  projectTitle: String;
  descPublic?: String;
  descInternal?: String;
  status?: ProjectPublishStatus;
  visibility?: ProjectVisibility;
  protectImages?: Boolean;
}

export interface VideoProjectPreviousValuesPromise
  extends Promise<VideoProjectPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  projectType: () => Promise<ProjectType>;
  projectTitle: () => Promise<String>;
  descPublic: () => Promise<String>;
  descInternal: () => Promise<String>;
  status: () => Promise<ProjectPublishStatus>;
  visibility: () => Promise<ProjectVisibility>;
  protectImages: () => Promise<Boolean>;
}

export interface VideoProjectPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoProjectPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  projectType: () => Promise<AsyncIterator<ProjectType>>;
  projectTitle: () => Promise<AsyncIterator<String>>;
  descPublic: () => Promise<AsyncIterator<String>>;
  descInternal: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<ProjectPublishStatus>>;
  visibility: () => Promise<AsyncIterator<ProjectVisibility>>;
  protectImages: () => Promise<AsyncIterator<Boolean>>;
}

export interface VideoProjectSubscriptionPayload {
  mutation: MutationType;
  node: VideoProject;
  updatedFields: String[];
  previousValues: VideoProjectPreviousValues;
}

export interface VideoProjectSubscriptionPayloadPromise
  extends Promise<VideoProjectSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = VideoProjectPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = VideoProjectPreviousValuesPromise>() => T;
}

export interface VideoProjectSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<VideoProjectSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = VideoProjectSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = VideoProjectPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface VideoUnitPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  descPublic?: String;
}

export interface VideoUnitPreviousValuesPromise
  extends Promise<VideoUnitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  descPublic: () => Promise<String>;
}

export interface VideoUnitPreviousValuesSubscription
  extends Promise<AsyncIterator<VideoUnitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  descPublic: () => Promise<AsyncIterator<String>>;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTeam {
  count: Int;
}

export interface AggregateTeamPromise
  extends Promise<AggregateTeam>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTeamSubscription
  extends Promise<AsyncIterator<AggregateTeam>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Permission",
    embedded: false
  },
  {
    name: "ContentType",
    embedded: false
  },
  {
    name: "ProjectType",
    embedded: false
  },
  {
    name: "VideoBurnedInStatus",
    embedded: false
  },
  {
    name: "VideoQuality",
    embedded: false
  },
  {
    name: "ImageQuality",
    embedded: false
  },
  {
    name: "ProjectPublishStatus",
    embedded: false
  },
  {
    name: "ProjectVisibility",
    embedded: false
  },
  {
    name: "TextDirection",
    embedded: false
  },
  {
    name: "ThumbnailSize",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Team",
    embedded: false
  },
  {
    name: "Language",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "LanguageTranslation",
    embedded: false
  },
  {
    name: "Thumbnail",
    embedded: false
  },
  {
    name: "VideoProject",
    embedded: false
  },
  {
    name: "VideoUnit",
    embedded: false
  },
  {
    name: "VideoStream",
    embedded: false
  },
  {
    name: "Dimensions",
    embedded: false
  },
  {
    name: "VideoUse",
    embedded: false
  },
  {
    name: "ImageUse",
    embedded: false
  },
  {
    name: "SupportFileUse",
    embedded: false
  },
  {
    name: "VideoFile",
    embedded: false
  },
  {
    name: "ImageFile",
    embedded: false
  },
  {
    name: "SupportFile",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
